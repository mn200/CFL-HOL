open HolKernel boolLib bossLib Parse

open stringTheory relationTheory listTheory
    rich_listTheory

open pred_setTheory symbolDefTheory grammarDefTheory listLemmasTheory
relationLemmasTheory

open containerLemmasTheory cnfTheory eProdsTheory generatingGrammarTheory
    unitProdsTheory aProdsTheory l2rTheory

val _ = new_theory "gnf";

val _ = Globals.linewidth := 60
val _ = set_trace "Unicode" 1

fun MAGIC (asl, w) = ACCEPT_TAC (mk_thm(asl,w)) (asl,w);

(*
Theorem 4.6
Every CFL L without can be generated by a grammar for
which every production is of the form A->aα, where A is a variable,
a is a terminal and alpha (possibly empty) is a string of variables.
*)


val seenInv = Define
`seenInv ru s = 
∀i. i < LENGTH s ⇒
   ∀nt rest. (rule (EL i s) (NTS nt :: rest)) ∈ ru ⇒
       ∀j. j ≤ i ⇒ EL j s ≠ nt`;


val elAppendList = store_thm
("elAppendList",
``∀i s1 s2.i < LENGTH s2 ⇒ (EL i s2 = EL (LENGTH s1 + i) (s1++s2))``,

Induct_on `s2` THEN SRW_TAC [][] THEN
Cases_on `i` THEN SRW_TAC [][] THEN
FULL_SIMP_TAC (srw_ss()) [] THEN1
METIS_TAC [NULL_EQ_NIL, NOT_CONS_NIL, HD, EL_LENGTH_APPEND] THEN
RES_TAC THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`s1++[h]`] MP_TAC) THEN 
SRW_TAC [][] THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`n`,`s1++[h]`] MP_TAC) THEN 
SRW_TAC [][] THEN
`s1 ++ [h]++s2 = s1++h::s2`by METIS_TAC [APPEND, APPEND_ASSOC] THEN
`LENGTH s1 + 1 + n  = LENGTH s1 + SUC n` by DECIDE_TAC THEN
METIS_TAC []);

val seenInvAppend = store_thm
("seenInvAppend",
``∀s1 s2.seenInv ru (s1++s2) ⇒ seenInv ru s1 ∧ seenInv ru s2``,

Induct_on `s1` THEN SRW_TAC [][] THEN1

SRW_TAC [][seenInv] THEN
FULL_SIMP_TAC (srw_ss()) [seenInv] THEN
SPOSE_NOT_THEN ASSUME_TAC THEN SRW_TAC [][] THEN
FULL_SIMP_TAC (srw_ss()) [] THEN1

(`i < SUC (LENGTH s1 + LENGTH s2)`by DECIDE_TAC THEN
RES_TAC THEN
`LENGTH (h::s1) = SUC (LENGTH s1)`by SRW_TAC [][] THEN
`EL i (h::s1) = EL i (h::(s1 ++ s2))` by METIS_TAC [EL_APPEND1, APPEND, 
						    APPEND_ASSOC] THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`rest`, `EL j (h::s1)`] MP_TAC) THEN SRW_TAC [][] THEN1
METIS_TAC [] THEN
`j < SUC (LENGTH s1)` by DECIDE_TAC THEN
 METIS_TAC [EL_APPEND1, APPEND, APPEND_ASSOC]) THEN

`LENGTH (h::s1) + i < SUC (LENGTH s1 + LENGTH s2)` 
 by FULL_SIMP_TAC (srw_ss()++ARITH_ss) [] THEN
RES_TAC THEN
`EL i s2 = EL (LENGTH (h::s1) + i) (h::(s1++s2))` 
 by METIS_TAC [elAppendList, APPEND,APPEND_ASSOC] THEN
SRW_TAC [][] THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`rest`,`EL j s2`] MP_TAC) THEN SRW_TAC [][] THEN
FULL_SIMP_TAC (srw_ss()) [] THEN
`j < SUC (LENGTH s1) + i` by DECIDE_TAC THEN
Q.EXISTS_TAC `LENGTH (h::s1) + j` THEN
SRW_TAC [][] THEN
`j < LENGTH s2` by DECIDE_TAC THEN
`EL j s2 = EL (LENGTH (h::s1) + j) (h::(s1++s2))` by
METIS_TAC [elAppendList, APPEND,APPEND_ASSOC] THEN
FULL_SIMP_TAC (srw_ss()) []);

val r49 = Define
`r49 (bs0: α list, nts0: α list, g0:(α,β) grammar, seen0: α list)
       (bs,nts,g,seen) =

∃ntk b.(nts0 = ntk::nts) ∧ (bs = bs0 ++ [b]) ∧ (seen = seen0 ++ [ntk]) ∧
       (nts = TL nts0) ∧

∃rules0. (rules0 = aProdsRules ntk seen0 NULL (set (rules g0))) ∧

∃rules1. (rules1 = l2rRules ntk b (rules0)) ∧

(startSym g = startSym g0) ∧ (set (rules g) = rules1)`;


val listExists4SetMem = store_thm
("listExists4SetMem",
``∀s.FINITE s ⇒ ∃r.∀e.MEM e r ⇔ e ∈ s``,

HO_MATCH_MP_TAC FINITE_INDUCT THEN SRW_TAC [][] THEN1
METIS_TAC [MEM,mem_in] THEN
METIS_TAC [MEM, mem_in]);


val listExists4Set = store_thm
("listExists4Set",
``∀s.FINITE s ⇒ ∃r.set r  = s``,

HO_MATCH_MP_TAC FINITE_INDUCT THEN SRW_TAC [][] THEN
Q.EXISTS_TAC `e::r`  THEN
SRW_TAC [][]);


val finiteaProdsRules = store_thm
("finiteaProdsRules",
``∀ru.FINITE ru ⇒ FINITE (aProdsRules A l PP ru)``,

HO_MATCH_MP_TAC FINITE_INDUCT THEN SRW_TAC [][] THEN1
(SRW_TAC [][aProdsRules, EXTENSION] THEN
 `{rule A (p ++ x ++ s) | (p,x,s) | F} = {}` by SRW_TAC [][EXTENSION] THEN
 FULL_SIMP_TAC (srw_ss()) []) THEN1

MAGIC);


val finitel2rRules = store_thm
("finitel2rRulese",
``FINITE ru ⇒ FINITE (l2rRules A B ru)``,

MAGIC);

val r49_equiv = prove
    (``∀g0 s0 nts0.
     ¬MEM b (ntms g0) ⇒
     (set nts0 ∩ set s0 = {}) ⇒
     ∀bs0 bs nts g s.
     r49 (b::bs0,nts0,g0,s0) (bs,nts,g,s) ⇒
     (language g0 = language g)``,

SRW_TAC [][r49] THEN
`FINITE (aProdsRules ntk s0 NULL (set (rules g0)))`
by METIS_TAC [FINITE_LIST_TO_SET, finiteaProdsRules] THEN
`∃r. set r = aProdsRules ntk s0 NULL (set (rules g0))` 
 by METIS_TAC [listExists4Set] THEN

`aProds ntk s0 NULL g0 (G r (startSym g0))` by

(SRW_TAC [][aProds, startSym_def, rules_def] THEN1
 
 (FULL_SIMP_TAC (srw_ss()) [INTER_DEF, EXTENSION] THEN
  METIS_TAC [MEM]) THEN

 FULL_SIMP_TAC (srw_ss()) [EXTENSION]) THEN
 
`language (G r (startSym g0)) = language g0` by METIS_TAC [lemma4_3Gen] THEN

 `∃r'. set r' = l2rRules ntk b
 (aProdsRules ntk s0 NULL (set (rules g0)))` 
 by METIS_TAC [listExists4Set, finitel2rRules] THEN


`left2Right ntk b (G r (startSym g0)) (G r' (startSym g0))`
     by (SRW_TAC [][startSym_def, rules_def, left2Right] THEN
	 MAGIC) THEN


`language (G r (startSym g0)) = language (G r'(startSym g0))` by
METIS_TAC [lemma4_4] THEN
MAGIC);


val r49_exists = store_thm
("r49_exists",
``¬MEM h' (h::t) ⇒ ∃u.r49 (b::t',ntk::t,g0,seen0) u ∧ 
 ∃g.(u = (t',t,g,seen0++[ntk]))``,

SRW_TAC [][] THEN
Q.ABBREV_TAC `rules0' = aProdsRules ntk seen0 NULL (set (rules g0))` THEN
`FINITE rules0'`
by METIS_TAC [FINITE_LIST_TO_SET, finiteaProdsRules] THEN
`∃r.set r = rules0'` 
 by METIS_TAC [listExists4Set] THEN
 `∃r'. set r' = l2rRules ntk b rules0'` 
 by METIS_TAC [listExists4Set, finitel2rRules] THEN
Q.EXISTS_TAC `(t',t,(G r' (startSym g0)),seen0++[ntk])` THEN
SRW_TAC [][r49, startSym_def, rules_def, LET_THM] THEN
UNABBREV_ALL_TAC THEN
FULL_SIMP_TAC (srw_ss()) [EXTENSION]);


val r49Rtc_exists = store_thm
("r49Rtc_exists",
``∀nts0 bs0.
 LENGTH bs0 ≥ LENGTH nts0 ⇒ 
 ALL_DISTINCT bs0 ∧ ALL_DISTINCT nts0 ⇒
 ∀seen0.(set nts0 ∩ set seen0 = {} ) ⇒
 ∀g0.(∀e.MEM e bs0 ⇒ ¬MEM e (ntms g0)) ⇒
 ∃g.(r49)^* (bs0, nts0, g0, seen0) (DROP (LENGTH nts0) bs0,[],g,seen0++nts0)``,

Induct_on `LENGTH nts0` THEN SRW_TAC [][] THEN1
(`nts0 = []` by METIS_TAC [LENGTH_NIL] THEN
 FULL_SIMP_TAC (srw_ss()) [] THEN
 SRW_TAC [][] THEN
 METIS_TAC [RTC_RULES]) THEN

Cases_on `nts0` THEN SRW_TAC [][] THEN
FULL_SIMP_TAC (srw_ss()) [] THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`t`] MP_TAC) THEN SRW_TAC [][] THEN
Cases_on `bs0` THEN FULL_SIMP_TAC (srw_ss()) [] THEN1
FULL_SIMP_TAC (arith_ss) [] THEN
`LENGTH t' ≥ LENGTH t` by DECIDE_TAC THEN
`¬MEM h' (h::t)`by MAGIC THEN
`∃u. r49 (h'::t',h::t,g0,seen0) u ∧
 ∃g. u = (t',t,g,seen0++[h])` by METIS_TAC [APPEND, r49Exists] THEN
SRW_TAC [][] THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`t'`] MP_TAC) THEN SRW_TAC [][] THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`seen0++[h]`] MP_TAC) THEN SRW_TAC [][] THEN
`(set t ∩ (set seen0 ∪ {h}) = {})` by
(FULL_SIMP_TAC (srw_ss()) [INTER_DEF, EXTENSION] THEN
 METIS_TAC []) THEN
RES_TAC THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`g`] MP_TAC) THEN SRW_TAC [][] THEN
`(∀e. e ∈ t' ⇒ ¬(e ∈ ntms g))` by MAGIC THEN
RES_TAC THEN
SRW_TAC [][Once RTC_CASES1] THEN
METIS_TAC [APPEND, APPEND_ASSOC]);


val r49Rtc_equiv = store_thm
("r49Rtc_equiv",
``∀s0 s.RTC r49 s0 s ⇒ 
 ∀bs0 nts0 g0 seen0.(s0=(bs0,nts0,g0,seen0)) ⇒
 (s = (bs,nts,g,seen)) ⇒
 LENGTH bs0 ≥ LENGTH nts0 ∧ ALL_DISTINCT bs0 ∧ 
 ALL_DISTINCT nts0 ∧
 (∀e.MEM e bs0 ⇒ ¬MEM e (ntms g0)) ⇒
 (set nts0 ∩ set seen0 = {}) ⇒
 (language g0 = language g)``,
 
HO_MATCH_MP_TAC RTC_STRONG_INDUCT THEN
SRW_TAC [][] THEN
`∃bs0' nts' g' seen'.(s0' = (bs',nts',g',seen'))` by MAGIC THEN
SRW_TAC [][] THEN
`∃ntk b.
 (nts0 = ntk::nts') ∧ (bs0 = b::bs') ∧
 (seen' = seen0 ++ [ntk]) ∧ (nts' = TL nts0)` by METIS_TAC [r49] THEN
SRW_TAC [][] THEN
`LENGTH bs' ≥ LENGTH (TL nts0)` by
(Cases_on `nts0` THEN FULL_SIMP_TAC (srw_ss()++ARITH_ss) []) THEN
`(set (TL nts0) ∩ set (seen0 ++ [ntk]) = {})` by MAGIC THEN
`ALL_DISTINCT (TL nts0)` by METIS_TAC [ALL_DISTINCT_APPEND, APPEND] THEN
`(∀e. e ∈ bs' ⇒ ¬(e ∈ ntms g'))` by MAGIC THEN
`ALL_DISTINCT bs'` by METIS_TAC [APPEND, ALL_DISTINCT_APPEND] THEN
RES_TAC THEN
METIS_TAC [r49_equiv, MEM]);


val r49_seenInv = prove
(``∀s0 g0 nts0 bs0. 
 seenInv (rules g0) s0 ∧ 
 (set nts0 ∩ set s0 = {}) ∧ 
 (set (ntms g0) ∩ set bs0 = {}) ⇒
 ∀bs0 bs nts g s.r49 (bs0,nts0,g0,s0) (bs,nts,g,s) ⇒
 seenInv (rules g) s``,

SRW_TAC [][r49] THEN
`FINITE (aProdsRules ntk s0 NULL (set (rules g0)))`
by METIS_TAC [FINITE_LIST_TO_SET, finiteaProdsRules] THEN
`∃r.set r =  aProdsRules ntk s0 NULL (set (rules g0))` 
 by METIS_TAC [listExists4Set] THEN
`seenInv r s0` by
(SRW_TAC [][seenInv,aProdsRules] THEN
 FULL_SIMP_TAC (srw_ss()) [rules_def,seenInv] THEN
 RES_TAC THEN
 FULL_SIMP_TAC (srw_ss()) [] THEN
 SRW_TAC [][] THEN
 `EL i s0 ∈ set s0` by METIS_TAC [MEM_EL, mem_in] THEN
 FULL_SIMP_TAC (srw_ss()) [INTER_DEF, EXTENSION] THEN
 METIS_TAC [MEM]) THEN


`∀i. i < LENGTH s0 ⇒
 (∀nt rest. rule ntk (NTS nt::rest) ∈ aProdsRules ntk s0 NULL (set (rules g0)) 
  ⇒ EL i s0 ≠ nt)` by 
 (SRW_TAC [][aProdsRules] THEN
  FULL_SIMP_TAC (srw_ss()) [seenInv] THEN1
  (SPOSE_NOT_THEN ASSUME_TAC THEN
   FULL_SIMP_TAC (srw_ss()) [] THEN
   SRW_TAC [][] THEN
   METIS_TAC [EL_IS_EL, NULL_EQ_NIL, APPEND_NIL, APPEND, APPEND_ASSOC]) THEN
  
  SPOSE_NOT_THEN ASSUME_TAC THEN SRW_TAC [][] THEN
  Cases_on `p` THEN FULL_SIMP_TAC (srw_ss()) [] THEN
  MAGIC) THEN

 `∃r'. set r' = l2rRules ntk b
 (aProdsRules ntk s0 NULL (set (rules g0)))` 
 by METIS_TAC [listExists4Set, finitel2rRules] THEN

`seenInv r' (s0 ++ [ntk])` by

(FULL_SIMP_TAC (srw_ss()) [seenInv, rules_def,l2rRules, newAprods, bprods] THEN 
 SRW_TAC [][] THEN1

(`i < LENGTH s0 ∨ (i = LENGTH s0)` by DECIDE_TAC THEN1
 (`EL j (s0++[ntk]) = EL j s0` by METIS_TAC [EL_APPEND1, DECIDE ``i < l ∧ j ≤ i
					    ⇒ j < l``] THEN
 `EL i (s0++[ntk]) = EL i s0` by METIS_TAC [EL_APPEND1, DECIDE ``i < l ∧ j ≤ i
					    ⇒ j < l``] THEN
  METIS_TAC []) THEN
`EL i (s0 ++ [ntk]) = ntk` by METIS_TAC [EL_LENGTH_APPEND, NULL_EQ_NIL, HD,
					 NOT_CONS_NIL,CONS] THEN
SRW_TAC [][] THEN
`EL (LENGTH s0) (s0++[ntk]) = ntk` by METIS_TAC [EL_LENGTH_APPEND, NULL_EQ_NIL, HD,
					 NOT_CONS_NIL,CONS] THEN
SRW_TAC [][] THEN
FULL_SIMP_TAC (srw_ss()) [] THEN
`j < LENGTH s0 ∨ (j = LENGTH s0)`by DECIDE_TAC THEN1
(`EL j (s0 ++ [ntk]) = EL j s0` by METIS_TAC [EL_APPEND1, DECIDE ``i < l ∧ j ≤ i
					    ⇒ j < l``] THEN METIS_TAC []) THEN
FULL_SIMP_TAC (srw_ss()) [recprods] THEN
METIS_TAC []) THEN
MAGIC) THEN

FULL_SIMP_TAC (srw_ss()) [seenInv, LET_THM] THEN
SRW_TAC [][] THEN
METIS_TAC [mem_in]);


val r49Rtc_seenInv = store_thm
("r49Rtc_seenInv",
 ``∀x y. (r49)^* x y ⇒ 
 ∀bs0 nts0 g0 s0. (x = (bs0,nts0,g0,s0)) ⇒ (y= (bs,nts,g,s)) ⇒
 seenInv (rules g0) s0 ∧ (set nts0 ∩ set s0 = {}) ∧ 
 (set (ntms g0) ∩ set bs0 = {})
 ⇒
 seenInv (rules g) s``,

HO_MATCH_MP_TAC RTC_STRONG_INDUCT THEN SRW_TAC [][] THEN
`∃bs1 nts1 g1 s1. (x' = (bs1, nts1, g1, s1))`by MAGIC THEN
SRW_TAC [][] THEN
`seenInv (rules g1) s1` by METIS_TAC [r49_seenInv] THEN
`∃ntk b. (nts0 = ntk::nts1) ∧ (bs0 = b::bs1) ∧
 (s1 = s0 ++ [ntk]) ∧ (nts1 = TL nts0)` by METIS_TAC [r49] THEN
SRW_TAC [][] THEN

`(set (TL nts0) ∩ set (s0 ++ [ntk]) = {})` by MAGIC THEN
 `(set (ntms g1) ∩ set bs1 = {})` by MAGIC THEN
METIS_TAC []);




val rhsTlNonTms = Define
`rhsTlNonTms ru ntsl bs = 
 (∀e. e ∈ (set ntsl DIFF set bs) ⇒
  (∀r.MEM (rule e r) ru ⇒ 
   ∃h t.(r = h::t) ∧ EVERY isNonTmnlSym t ∧ (isNonTmnlSym h ⇒ t ≠ []))) ∧
 (∀e. MEM e bs ⇒ ∀r. MEM (rule e r) ru ⇒ EVERY isNonTmnlSym r ∧ r ≠ [])`;


val isCnfImprhsTlNonTmnls = store_thm
("isCnfImprhsTlNonTmnls",
``isCnf g0 ⇒ (set (ntms g0) ∩ set bs0 = {}) ⇒
 rhsTlNonTms (rules g0) (ntms g0) bs0``,

SRW_TAC [][isCnf_def, rhsTlNonTms] THEN
RES_TAC 
 THENL[
       Cases_on `r` THEN FULL_SIMP_TAC (srw_ss()) [] THEN
       Cases_on `h` THEN FULL_SIMP_TAC (srw_ss()) [isNonTmnlSym_def, isTmnlSym_def] THEN
       METIS_TAC [LENGTH_NIL, EVERY_DEF, DECIDE ``1 ≠ 0``],

       Cases_on `r` THEN FULL_SIMP_TAC (srw_ss()) [] THEN
       Cases_on `h` THEN FULL_SIMP_TAC (srw_ss()) [isNonTmnlSym_def, isTmnlSym_def] THEN
       METIS_TAC [LENGTH_NIL, EVERY_DEF, DECIDE ``1 ≠ 0``],

       FULL_SIMP_TAC (srw_ss()) [EXTENSION] THEN
       METIS_TAC [ntmsMem, slemma1_4],

       Cases_on `r` THEN FULL_SIMP_TAC (srw_ss()) [] THEN
       Cases_on `h` THEN FULL_SIMP_TAC (srw_ss()) [isNonTmnlSym_def, isTmnlSym_def] THEN
       METIS_TAC [LENGTH_NIL, EVERY_DEF, DECIDE ``1 ≠ 0``],

       FULL_SIMP_TAC (srw_ss()) [EXTENSION] THEN
       METIS_TAC [ntmsMem, slemma1_4]       
       ]);


val aprodsrhsTl = store_thm
("aprodsrhsTl",
``rhsTlNonTms ru (ntms (G ru s)) bs0 ⇒ 
 (set (ntms (G ru s)) ∩ set bs0 = {}) ⇒
 (set ru' = aProdsRules ntk seen0 NULL (set ru))  ⇒ 
 rhsTlNonTms ru' (ntms (G ru' s)) bs0``,
MAGIC);

SRW_TAC [][rhsTlNonTms] THEN
`rule e r ∈ aProdsRules ntk seen0 NULL (set ru)` by METIS_TAC [mem_in] THEN
FULL_SIMP_TAC (srw_ss()) [aProdsRules] THEN1
METIS_TAC [ntmsMem, slemma1_4, rules_def] THEN
Cases_on `p` THEN FULL_SIMP_TAC (srw_ss()) [] THEN
SRW_TAC [][] THEN
`e ∈ (ntms (G ru s))`by METIS_TAC [slemma1_4, rules_def,ntmsMem] THEN
`B ∈ (ntms (G ru s))` by METIS_TAC [slemma1_4, rules_def,ntmsMem] THEN 
RES_TAC THEN
Cases_on `x` THEN FULL_SIMP_TAC (srw_ss()) [] THEN
Cases_on `h` THEN FULL_SIMP_TAC (srw_ss()) [] THEN SRW_TAC [][] THEN
FULL_SIMP_TAC (srw_ss()) [isNonTmnlSym_def] THEN
DECIDE_TAC);


val l2rrhsTl = store_thm
("l2rrhsTl",
``(set (ntms (G ru s)) ∩ set (B::bs) = {}) ⇒
 rhsTlNonTms ru (ntms (G ru s)) (B::bs) ⇒ 
 (set ru' = l2rRules A B (set ru)) ⇒
 rhsTlNonTms ru' (ntms (G ru' s)) (B::bs)``,
MAGIC);


SRW_TAC [][rhsTlNonTms] THEN

`rule e r ∈ l2rRules A B (set ru)` by METIS_TAC [mem_in] THEN
FULL_SIMP_TAC (srw_ss()) [l2rRules] THEN1
METIS_TAC [slemma1_4, ntmsMem, rules_def] THEN1
(FULL_SIMP_TAC (srw_ss()) [newAprods] THEN
SRW_TAC [][]  THEN
RES_TAC THEN
Cases_on `y` THEN FULL_SIMP_TAC (srw_ss()) [isNonTmnlSym_def] THEN
`A ∈ (ntms (G ru s))` by METIS_TAC [slemma1_4, rules_def, ntmsMem] THEN
RES_TAC THEN
FULL_SIMP_TAC (srw_ss()) [] THEN
SRW_TAC [][] THEN
DECIDE_TAC) THEN

FULL_SIMP_TAC (srw_ss()) [bprods] THEN
SRW_TAC [][] THEN1

(`A ∈ (ntms (G ru s))` by METIS_TAC [slemma1_4, rules_def, ntmsMem] THEN
 RES_TAC  THEN
 FULL_SIMP_TAC (srw_ss()) [isNonTmnlSym_def] THEN
 SRW_TAC [][] THEN
 Cases_on `r` THEN FULL_SIMP_TAC (srw_ss()) [] THEN
Cases_on `h` THEN FULL_SIMP_TAC (srw_ss()) [isNonTmnlSym_def]
 ) THEN

`A ∈ (ntms (G ru s))` by METIS_TAC [slemma1_4, rules_def, ntmsMem] THEN
 RES_TAC  THEN
 FULL_SIMP_TAC (srw_ss()) [isNonTmnlSym_def] THEN
 SRW_TAC [][] THEN
Cases_on `a` THEN FULL_SIMP_TAC (srw_ss()) [isNonTmnlSym_def]);


val r49_rhsTlNonTms = store_thm
("r49_rhsTlNonTms",
``(set (ntms g0) ∩ set bs0 = {}) ∧
 rhsTlNonTms (rules g0) (ntms g0) bs0 ∧ 
 r49 (bs0,nts0,g0,s0) (bs,nts,g,s) ⇒
 rhsTlNonTms (rules g) (ntms g) bs0``,
MAGIC);

SRW_TAC [][] THEN
FULL_SIMP_TAC (srw_ss()) [r49] THEN
SRW_TAC [][] THEN
Q.ABBREV_TAC `rules0 = aProdsRules ntk seen0 NULL (set (rules g0))` THEN
`FINITE rules0`
by METIS_TAC [FINITE_LIST_TO_SET, finiteaProdsRules] THEN
`∃r. set r = rules0` by METIS_TAC [listExists4Set] THEN
Q.ABBREV_TAC `rules1 = l2rRules ntk b (set r)` THEN
 `∃r'. set r' =  rules1` 
 by METIS_TAC [listExists4Set, finitel2rRules, FINITE_LIST_TO_SET] THEN
Cases_on `g0` THEN FULL_SIMP_TAC (srw_ss()) [rules_def, startSym_def] THEN
`set (b::bs) = b INSERT set bs` by SRW_TAC [][] THEN
`rhsTlNonTms r (ntms (G r n)) (b::bs)` by METIS_TAC [aprodsrhsTl] THEN
`set (ntms (G r n)) ∩ (b INSERT set bs) = {}` by MAGIC THEN
`rhsTlNonTms r' (ntms (G r n)) (b::bs)` by METIS_TAC [l2rrhsTl, mem_in] THEN
UNABBREV_ALL_TAC THEN
FULL_SIMP_TAC (srw_ss()) [] THEN
Cases_on `g` THEN FULL_SIMP_TAC (srw_ss()) [startSym_def, rules_def] THEN
SRW_TAC [][] THEN
MAGIC);


``(set r = aProdsRules ntk s0 NULL (set (rules g0))) ⇒
(set (ntms g) ⊆ set (ntms g0))``,

SRW_TAC [][aProdsRules, EXTENSION, EQ_IMP_THM, SUBSET_DEF] THEN
SRW_TAC [][] THEN

``(set r = l2rRules ntk b (set (rules g0))) ⇒
(set (ntms g) = set (ntms g0) ∪ {b})``,



``r49 (b::bs,nts0,g0,s0) (bs,nts,g,s) ⇒
(set (ntms g) ⊆ set (ntms g0) ∪ {b})``,

SRW_TAC [][r49] THEN

r49 (bs0,nts0,g0,s0) (bs,nts,g,s) ⇒
(∀e. MEM e bs ⇒ ∀r. MEM (rule e r)


val rhsTlNtmsRtc = store_thm
("rhsTlNtmsRtc",
``∀x y. (r49)^* x y ⇒ 
 ∀bs0 nts0 g0 s0. (x = (bs0,nts0,g0,s0)) ⇒ (y = (bs,nts,g,s)) ⇒
 (set (ntms g0) ∩ set bs0 = {}) ⇒
 rhsTlNonTms (rules g0) (ntms g0) bs0 ⇒
 rhsTlNonTms (rules g) (ntms g) bs0``,

HO_MATCH_MP_TAC RTC_STRONG_INDUCT THEN SRW_TAC [][] THEN
`∃bs1 nts1 g1 s1. (x' = (bs1, nts1, g1, s1))`by MAGIC THEN
SRW_TAC [][] THEN
IMP_RES_TAC r49_rhsTlNonTms THEN
FULL_SIMP_TAC (srw_ss()) [r49] THEN
SRW_TAC [][] THEN





MAGIC);


val bInv = Define
`bInv ru ntsl bs = 
∀e.MEM e bs ⇒ 
∀n rst. rule e (NTS n::rst) ∈ ru ⇒ n ∈ set ntsl`;

val aprods_bInv = store_thm
("aprods_bInv",
``bInv (rules g0) (ntms g0) bs0 ⇒
 (set (ntms g0) ∩ set bs0 = {}) ⇒
 (set r = aProdsRules ntk s0 NULL (set (rules g0))) ⇒
 bInv r (ntms g0) bs0``,

SRW_TAC [][bInv] THEN
`rule e (NTS n::rst) ∈ aProdsRules ntk s0 NULL (set (rules g0))`
 by METIS_TAC [mem_in] THEN
FULL_SIMP_TAC (srw_ss()) [aProdsRules] THEN1
METIS_TAC [slemma1_4] THEN
SRW_TAC [][] THEN
Cases_on `p` THEN Cases_on `x` THEN Cases_on `s` THEN
FULL_SIMP_TAC (srw_ss()) [] THEN
SRW_TAC [][] THEN
METIS_TAC [slemma1_4, APPEND, symbol_11, APPEND_ASSOC, ntmsMem]);


val l2r_bInv = store_thm
("l2r_bInv",
``bInv ru (ntms (G ru s)) (b::bs0) ⇒
 rhsTlNonTms ru ⇒
 (set (ntms (G ru s)) ∩ set (b::bs0) = {}) ⇒
(set r = l2rRules ntk b (set ru)) ⇒
 bInv r (ntms (G ru s)) (b::bs0)``,

SRW_TAC [][bInv, l2rRules] 
 THENL[

`rule b (NTS n::rst) ∈ 
 set ru ∪ newAprods ntk b (set ru) ∪
 bprods ntk b (set ru) DIFF recprods ntk (set ru)` by METIS_TAC [mem_in] THEN
FULL_SIMP_TAC (srw_ss()) [] 
THENL[
      `NTS b ∈ nonTerminals (G ru s)` by METIS_TAC [rules_def, slemma1_4] THEN
      IMP_RES_TAC ntmsMem THEN
      FULL_SIMP_TAC (srw_ss()) [EXTENSION] THEN
      METIS_TAC [],

      FULL_SIMP_TAC (srw_ss()) [newAprods] THEN
      SRW_TAC [][] THEN
      `NTS b ∈ nonTerminals (G ru s)` by METIS_TAC [rules_def, slemma1_4] THEN
      IMP_RES_TAC ntmsMem THEN
      FULL_SIMP_TAC (srw_ss()) [EXTENSION] THEN
      METIS_TAC [],

      FULL_SIMP_TAC (srw_ss()) [bprods] THEN1
      (`NTS n ∈ nonTerminals (G ru s)` by METIS_TAC [rules_def, slemma1_4,
						     APPEND, APPEND_ASSOC] THEN
       METIS_TAC [ntmsMem]) THEN
      FULL_SIMP_TAC (srw_ss()) [rhsTlNonTms] THEN
      RES_TAC THEN
      


      Cases_on `a` THEN FULL_SIMP_TAC (srw_ss()) [noEmptyRules] THEN
      SRW_TAC [][] THEN

      FULL_SIMP_TAC (srw_ss()) [recprods]

      
      


      ]


val r49_bInv = store_thm
("r49_bInv",
 ``∀s0 g0 nts0 bs0. 
 (set bs0 ∩ set nts0 = {}) ⇒
 (set (ntms g0) ∩ set bs0 = {}) ⇒
 bInv (rules g0) (ntms g0) bs0 ⇒
 r49 (bs0,nts0,g0,s0) (bs,nts,g,s) ⇒
 bInv (rules g) (ntms g0) bs0``,

 SRW_TAC [][r49] THEN
`FINITE (aProdsRules ntk s0 NULL (set (rules g0)))`
by METIS_TAC [FINITE_LIST_TO_SET, finiteaProdsRules] THEN
`∃r. set r = aProdsRules ntk s0 NULL (set (rules g0))` 
 by METIS_TAC [listExists4Set] THEN
`bInv r (ntms g0) (b::bs)` by METIS_TAC [aprods_bInv] THEN

IMP_RES_TAC ruleRhsInntms THEN
 FULL_SIMP_TAC (srw_ss()) [isNonTmnlSym_def] THEN
 SRW_TAC[][] THEN
MAGIC);


val r49Rtc_bInv = store_thm
("r49Rtc_bInv",
 ``∀x y.(r49)^* x y ⇒ 
  ∀bs0 nts0 g0 s0. (x = (bs0,nts0,g0,s0)) ⇒ (y= (bs,nts,g,s)) ⇒
  (set (ntms g0) ∩ set bs0 = {})
  (set bs0 ∩ set nts0 = {}) ⇒
  bInv (rules g0) (ntms g0) bs0 ⇒
  bInv (rules g) (ntms g0) bs0``,

HO_MATCH_MP_TAC RTC_STRONG_INDUCT THEN SRW_TAC [][] THEN
`∃bs1 nts1 g1 s1. (x' = (bs1,nts1,g1,s1))` by MAGIC THEN
SRW_TAC [][] THEN
IMP_RES_TAC r49_bInv THEN
FULL_SIMP_TAC (srw_ss()) [r49] THEN
SRW_TAC [][] THEN
`set bs1 ∩ set (TL nts0) = {}`
by (`set (b::bs1) ∩ set (ntk::TL nts0) = {}` by METIS_TAC [] THEN
    FULL_SIMP_TAC (srw_ss()) [EXTENSION] THEN
    METIS_TAC []) THEN
FULL_SIMP_TAC (srw_ss()) [bInv] THEN
SRW_TAC [][] THEN
 IMP_RES_TAC ruleRhsInntms THEN
 FULL_SIMP_TAC (srw_ss()) [isNonTmnlSym_def] THEN
 METIS_TAC [symbol_11]);


val ntmsMem = store_thm
("ntmsMem",
``MEM b (ntms g) ⇔ NTS b ∈ nonTerminals g``,

MAGIC);



val validGnfProd = Define 
`validGnfProd (rule l r) = 
    ∃ts ntsl.(r = ts::ntsl) ∧ isTmnlSym ts ∧ EVERY isNonTmnlSym ntsl`;

val isGnf = Define 
`isGnf g = EVERY validGnfProd (rules g)`;


val fstNtm2Tm = Define
`fstNtm2Tm (ontms0,g0,seen0) (ontms,g,seen) = 
∃ntj.
(ontms0 = ontms++[ntj]) ∧
(seen = ntj::seen0) ∧
(set (rules g) = 
 set (rules g0) DIFF
 {rule ntj ([NTS ntk] ++ s) |
  (ntk,s) | ntk ∈ seen0 ∧ rule ntj ([NTS ntk] ++ s) ∈ (set (rules g0))} ∪
 {rule ntj (x ++ s) | (x,s) |
  ∃ntk. ntk ∈ seen0 ∧ rule ntj ([NTS ntk] ++ s) ∈ (set (rules g0)) ∧
  rule ntk x ∈ (set (rules g0)) ∧ validGnfProd (rule ntk x) }) ∧
(startSym g0 = startSym g)`;

val gnfInv = Define
`gnfInv ru s = 
∀i. i < LENGTH s ⇒
∀r. rule (EL i s) r ∈ ru ⇒ validGnfProd (rule (EL i s) r) ∨ (r=[]) `;

(*
``gnfInv (rules g0) s0 ⇒
 (ntsl g0 = REVERSE (ontms0 ++ s0)) ⇒
(* seenInv (rules g0) (ntsl g0) ⇒*)
 fstNtm2Tm (ontms0,g0,s0) (ontms,g,s) ⇒
 gnfInv (rules g) s``,
*)

val ruleInv = Define
`ruleInv ru ontms s =
     ∀i.
     i < LENGTH ontms ⇒
     ∀nt rst. rule (EL i ontms) (NTS nt::rst) ∈ ru ⇒ nt ∈ (DROP i ontms ++ s)`;


val fstNtm2Tm_gnfInv = store_thm
("fstNtm2Tm_gnfInv",
`` ALL_DISTINCT (ontms0 ++ s0) ⇒
 rhsTlNonTms (rules g0) ⇒
 seenInv (rules g0) ontms0 ⇒
 ruleInv (rules g0) ontms0 s0 ⇒
 gnfInv (rules g0) s0 ⇒
 fstNtm2Tm (ontms0,g0,s0) (ontms,g,s) ⇒
 gnfInv (rules g) s``,

SRW_TAC [][fstNtm2Tm] THEN
FULL_SIMP_TAC (srw_ss()) [gnfInv] THEN
SRW_TAC [][] THEN
`rule (EL i (ntj::s0)) r ∈
set (rules g0) DIFF
      {rule ntj (NTS ntk::s) |
       (ntk,s) |
       ntk ∈ s0 ∧ rule ntj (NTS ntk::s) ∈ rules g0} ∪
      {rule ntj (x ++ s) |
       (x,s) |
       ∃ntk.
         ntk ∈ s0 ∧ rule ntj (NTS ntk::s) ∈ rules g0 ∧
         rule ntk x ∈ rules g0 ∧ validGnfProd (rule ntk x)}`
 by METIS_TAC [mem_in] THEN
FULL_SIMP_TAC (srw_ss()) [validGnfProd]
 THENL[


       `i < LENGTH s0 ∨ (i = LENGTH s0)`by DECIDE_TAC THEN
       MAGIC,

       MAGIC
       ]);



val fstNtm2Tm_ruleInv = store_thm
("fstNtm2Tm_ruleInv",
``ALL_DISTINCT (ontms0 ++ s0) ⇒
 rhsTlNonTms (rules g0) ⇒
 seenInv (rules g0) ontms0 ⇒
 ruleInv (rules g0) ontms0 s0 ⇒
 gnfInv (rules g0) s0 ⇒
 fstNtm2Tm (ontms0,g0,s0) (ontms,g,s) ⇒
 ruleInv (rules g) ontms s``,

SRW_TAC [][fstNtm2Tm] THEN
FULL_SIMP_TAC (srw_ss()) [ruleInv] THEN
SRW_TAC [][] THEN

`i < LENGTH ontms + 1` by DECIDE_TAC THEN
`rule (EL i (s0 ++ [ntj])) (NTS nt::rst) ∈ 
set (rules g0) DIFF
      {rule ntj (NTS ntk::s) |
       (ntk,s) |
       ntk ∈ s0 ∧ rule ntj (NTS ntk::s) ∈ rules g0} ∪
      {rule ntj (x ++ s) |
       (x,s) |
       ∃ntk.
         ntk ∈ s0 ∧ rule ntj (NTS ntk::s) ∈ rules g0 ∧
         rule ntk x ∈ rules g0 ∧ validGnfProd (rule ntk x)}`
 by METIS_TAC [mem_in] THEN
FULL_SIMP_TAC (srw_ss()) [] 
THENL
 [
  `i < LENGTH s0` by MAGIC THEN
  `EL i (s0 ++ [ntj]) = EL i s0` by MAGIC THEN
  FULL_SIMP_TAC (srw_ss()) [] THEN
  MAGIC,

  
  MAGIC,

  MAGIC,

  MAGIC
  ]);


val fstNtm2Tm_equiv = store_thm
("fstNtm2Tm_equiv",
``ALL_DISTINCT (ontms0 ++ s0) ⇒
 (* rhsTlNonTms (rules g0) ⇒
 seenInv (rules g0) ontms0 ⇒
 ruleInv (rules g0) ontms0 s0 ⇒ *)
 gnfInv (rules g0) s0 ⇒ 
 fstNtm2Tm (ontms0,g0,s0) (ontms,g,s) ⇒
 (language g0 = language g)``,

MAGIC);

val fstNtm2Tm_exists = store_thm
("fstNtm2Tm_exists",
 ``∃g. fstNtm2Tm (ontms++[ntj],g0,s0) (ontms,g,ntj::s0)``,

 SRW_TAC [][fstNtm2Tm] THEN
Q.ABBREV_TAC `r = set (rules g0) DIFF
   {rule ntj (NTS ntk::s) |
    (ntk,s) |
    ntk ∈ s0 ∧ rule ntj (NTS ntk::s) ∈ rules g0} ∪
   {rule ntj (x ++ s) |
    (x,s) |
    ∃ntk.
      ntk ∈ s0 ∧ rule ntj (NTS ntk::s) ∈ rules g0 ∧
      rule ntk x ∈ rules g0 ∧ validGnfProd (rule ntk x)}` THEN
`FINITE r` by MAGIC THEN
`∃rl.∀e. MEM e rl ⇔ e ∈ r` by METIS_TAC [listExists4Set] THEN

Q.EXISTS_TAC `(G rl (startSym g0))` THEN
SRW_TAC [][r49, startSym_def, rules_def, LET_THM] THEN
UNABBREV_ALL_TAC THEN
FULL_SIMP_TAC (srw_ss()) [EXTENSION]);

val fstNtm2TmRtc_exists = store_thm
("fstNtm2TmRtc_exists",
 ``∀ontms0 g0 s0.
 ∃g. (fstNtm2Tm)^* (ontms0,g0,s0) ([],g,ontms0++s0)``,

HO_MATCH_MP_TAC SNOC_INDUCT THEN SRW_TAC [][SNOC_APPEND] THEN1
METIS_TAC [RTC_RULES] THEN
SRW_TAC [][Once RTC_CASES1] THEN

`∃g. fstNtm2Tm (ontms0 ++ [x],g0,s0) (ontms0,g,x::s0)` by METIS_TAC [fstNtm2Tm_exists] THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`g`,`x::s0`] MP_TAC) THEN SRW_TAC [][] THEN
Q.EXISTS_TAC `g'` THEN
Q.EXISTS_TAC `(ontms0,g,x::s0)` THEN
METIS_TAC [APPEND_ASSOC, APPEND]);


val fstNtm2TmRtcLangEq = store_thm
("fstNtm2TmRtcLangEq",
``(fstNtm2Tm)^* (ontms0,g0,s0) (ontms,g,s) ⇒ (language g0 = language g)``,

MAGIC);


val ugImpcnf = store_thm
("ugImpcnf",
 ``usefulnts g0 g1 ∧ isCnf g0 ⇒ isCnf g1``,

Cases_on `g0` THEN
SRW_TAC [][usefulnts_def, startSym_def, rules_def] THEN
FULL_SIMP_TAC (srw_ss()) [isCnf_def, rules_def] THEN
SRW_TAC [][] THEN
METIS_TAC []);

val gnfExists = store_thm
("gnfExists",
``∀g:('a, 'b) grammar. 
 INFINITE (UNIV:'a set) ∧ 
 [] ∉ language g ∧
 language g ≠ {}  ⇒ 
 ∃g'.isGnf g' ∧ (language g = language g')``,

SRW_TAC [][] THEN
`∃cg. isCnf cg ∧ (language g = language cg)` by METIS_TAC [cnfisCnfEq, thm4_5,
							    eqLang_def] THEN
 `∃ug. usefulnts cg ug ∧ (language cg = language ug)` by
METIS_TAC [use_exists, lemma4_1a] THEN
`isCnf ug` by METIS_TAC [ugImpcnf] THEN
`ALL_DISTINCT (ntms ug)` by MAGIC THEN
 `∃bs0.ALL_DISTINCT bs0 ∧ (LENGTH bs0 ≥ LENGTH (ntms ug)) ∧
 (set (ntms ug) ∩ set bs0 = {})` by MAGIC THEN

`set (ntms ug) ∩ set ([]:'a list) = {}` by MAGIC THEN

`seenInv (rules ug) ([]:'a list)` by SRW_TAC [][seenInv] THEN

`(∀e. e ∈ bs0 ⇒ ¬(e ∈ ntms ug))` by MAGIC THEN


`∃g1.(r49)^* (bs0, ntms ug, ug, ([]:'a list)) 
			   (DROP (LENGTH (ntms ug)) bs0, ([]:'a list), g1,ntms ug) ∧
			   (language ug = language g1)`
 by METIS_TAC [r49RtcExists, rtcr49RtcLangeq, APPEND_NIL] THEN

`seenInv (rules g1) (ntms ug)` by METIS_TAC [r49Rtc_seenInv] THEN

`rhsTlNonTms (rules ug)` by METIS_TAC [isCnfImprhsTlNonTmnls] THEN

`rhsTlNonTms (rules g1)` by METIS_TAC [rhsTlNtmsRtc] THEN

`∀nt. nt ∈ (ntms ug) ⇒ gaw ug (NTS nt)` by METIS_TAC [lemma4_1,
						      ntmsMem] THEN

`∀nt. nt ∈ (ntms g1) ⇒ gaw g1 (NTS nt)` by METIS_TAC [r49Rtc_usefulInv,
						      usefulInv] THEN
Q.ABBREV_TAC `bs = DROP (LENGTH (ntms ug)) bs0` THEN

`gaw g1 nt (LAST (ntms g1))`

`∃ts. rule (LAST (ntms g1)) [TS ts] ∈ rules g1`

`∃ts. rule (LAST (ntms g1)) [TS ts] ∈ rules g2`

`∃g2. (fstNtm2Tm)^* (ntms ug, g1) ([],g2) ∧ eqLang g1 g2 ∧
			   inGnf (rules g3)-b rules`


`bInv (rules g1) (ntms g1) bs`

`bInv (rules g2) (ntms g2) bs`

`usefulInv g2`


`∃g3. (fstNtm2Tm)^* (TAKE (LENGTH ntms g1) bs0, g2) ([],g3) ∧ eqLang g2 g3 ∧
			   inGnf (rules g3)`



MAGIC);



 



val _ = export_theory ();



