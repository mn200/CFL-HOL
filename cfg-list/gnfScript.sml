open HolKernel boolLib bossLib Parse

open stringTheory relationTheory listTheory
    rich_listTheory

open pred_setTheory symbolDefTheory grammarDefTheory listLemmasTheory
relationLemmasTheory

open containerLemmasTheory cnfTheory eProdsTheory generatingGrammarTheory
    unitProdsTheory aProdsTheory l2rTheory

val _ = new_theory "gnf";

val _ = Globals.linewidth := 60
val _ = set_trace "Unicode" 1

fun MAGIC (asl, w) = ACCEPT_TAC (mk_thm(asl,w)) (asl,w);


val memnonTmnls = store_thm
("memnonTmnls",
``MEM b (nonTmnls l) ⇔
(∃r.MEM (rule b r) l) ∨ (∃nt r.MEM (rule nt r) l ∧ MEM (NTS b) r)``,

Induct_on `l` THEN SRW_TAC [][nonTmnls_def] THEN
Cases_on `h` THEN
FULL_SIMP_TAC (srw_ss()) [nonTmnls_def] THEN
SRW_TAC [][EQ_IMP_THM] THEN1
METIS_TAC [] THEN1
(FULL_SIMP_TAC (srw_ss()) [MEM_MAP] THEN
 SRW_TAC [][] THEN
 FULL_SIMP_TAC (srw_ss()) [MEM_FILTER] THEN
 SRW_TAC [][] THEN
 Cases_on `y` THEN FULL_SIMP_TAC (srw_ss()) [isNonTmnlSym_def, nts2str_def] THEN
 METIS_TAC []) THEN1
METIS_TAC [] THEN1
METIS_TAC [] THEN1
METIS_TAC [] THEN1
(FULL_SIMP_TAC (srw_ss()) [rgr_r9eq] THEN
 SRW_TAC [][FILTER_APPEND, isNonTmnlSym_def, nts2str_def] THEN
 METIS_TAC []) THEN
METIS_TAC []);


val slemma1_4ntms = store_thm
("slemma1_4ntms",
 ``MEM nt (ntms g) =
 (∃rhs.MEM (rule nt rhs) (rules g) ∨
  ∃l p s.MEM (rule l (p++[NTS nt]++s))(rules g) ∨
  (nt=startSym g))``,

 Cases_on `g` THEN SRW_TAC [] [EQ_IMP_THM] THEN
FULL_SIMP_TAC (srw_ss()) [ntms_def,rules_def,startSym_def, ntList_def,
			  nonTerminalsList_def, nonTmnls_def] THEN
METIS_TAC [MEM, rmd_r2, memnonTmnls, rgr_r9eq]);

val ntmsMem = store_thm
("ntmsMem",
``MEM b (ntms g) ⇔ NTS b ∈ nonTerminals g``,

METIS_TAC [slemma1_4ntms, slemma1_4]);

val listExists4SetMem = store_thm
("listExists4SetMem",
``∀s.FINITE s ⇒ ∃r.∀e.MEM e r ⇔ e ∈ s``,

HO_MATCH_MP_TAC FINITE_INDUCT THEN SRW_TAC [][] THEN1
METIS_TAC [MEM,mem_in] THEN
METIS_TAC [MEM, mem_in]);


val listExists4Set = store_thm
("listExists4Set",
``∀s.FINITE s ⇒ ∃r.set r  = s``,

HO_MATCH_MP_TAC FINITE_INDUCT THEN SRW_TAC [][] THEN
Q.EXISTS_TAC `e::r`  THEN
SRW_TAC [][]);


val finiteaProdAllRules = store_thm
("finiteaProdAllRules",
``∀ru. FINITE ru ⇒ FINITE (aProdAllRules A l PP ru)``,
MAGIC);

val finitel2rRules = store_thm
("finitel2rRulese",
``FINITE ru ⇒ FINITE (l2rRules A B ru)``,

MAGIC);


(*
Theorem 4.6
Every CFL L without can be generated by a grammar for
which every production is of the form A->aα, where A is a variable,
a is a terminal and alpha (possibly empty) is a string of variables.
*)


val r49Elem = Define
`r49Elem ntk (seen0,ru0,sl0) (seen,ru,sl) = 
∃se. (seen0 = se::seen) ∧ (sl = sl0++[se]) ∧
(set ru = aProdAllRules ntk se NULL (set ru0))`;

(***********************************************************************************)
(* NO EPRODS INV *)
(***********************************************************************************)


val noeProds = Define
`noeProds ru = ¬∃l. rule l [] ∈ ru`;

val r49E_noeProds = store_thm
("r49E_noeProds",
``noeProds ru0 ⇒
r49Elem ntk (seen0,ru0,sl0) (seen,ru,sl) ⇒
noeProds ru``,

SRW_TAC [][r49Elem, noeProds] THEN
SPOSE_NOT_THEN ASSUME_TAC THEN SRW_TAC [][] THEN
`rule l [] ∈ aProdAllRules ntk se NULL (set ru0)` by METIS_TAC [mem_in] THEN
FULL_SIMP_TAC (srw_ss()) [aProdAllRules_def] THEN
SRW_TAC [][] THEN
METIS_TAC []);

val r49ERtc_noeProds = store_thm
("r49ERtc_noeProds",
``∀x y. (r49Elem ntk)^* x y ⇒ 
∀seen0 ru0 sl0. (x=(seen0,ru0,sl0)) ⇒ (y=(seen,ru,sl)) ⇒
noeProds ru0 ⇒
noeProds ru``,

HO_MATCH_MP_TAC RTC_STRONG_INDUCT THEN SRW_TAC [][] THEN
`∃seen1 ru1 sl1. (x' = (seen1,ru1,sl1))` by MAGIC THEN
SRW_TAC [][] THEN
METIS_TAC [r49E_noeProds]);

(***********************************************************************************)
(* SEEN INV *)
(***********************************************************************************)


val seenInv = Define
`seenInv ru s = 
∀i. i < LENGTH s ⇒
   ∀nt rest. (rule (EL i s) (NTS nt :: rest)) ∈ ru ⇒
       ∀j. j ≤ i ⇒ EL j s ≠ nt`;


val elAppendList = store_thm
("elAppendList",
``∀i s1 s2.i < LENGTH s2 ⇒ (EL i s2 = EL (LENGTH s1 + i) (s1++s2))``,

Induct_on `s2` THEN SRW_TAC [][] THEN
Cases_on `i` THEN SRW_TAC [][] THEN
FULL_SIMP_TAC (srw_ss()) [] THEN1
METIS_TAC [NULL_EQ_NIL, NOT_CONS_NIL, HD, EL_LENGTH_APPEND] THEN
RES_TAC THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`s1++[h]`] MP_TAC) THEN 
SRW_TAC [][] THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`n`,`s1++[h]`] MP_TAC) THEN 
SRW_TAC [][] THEN
`s1 ++ [h]++s2 = s1++h::s2`by METIS_TAC [APPEND, APPEND_ASSOC] THEN
`LENGTH s1 + 1 + n  = LENGTH s1 + SUC n` by DECIDE_TAC THEN
METIS_TAC []);

val seenInvAppend = store_thm
("seenInvAppend",
``∀s1 s2.seenInv ru (s1++s2) ⇒ seenInv ru s1 ∧ seenInv ru s2``,

Induct_on `s1` THEN SRW_TAC [][] THEN1

SRW_TAC [][seenInv] THEN
FULL_SIMP_TAC (srw_ss()) [seenInv] THEN
SPOSE_NOT_THEN ASSUME_TAC THEN SRW_TAC [][] THEN
FULL_SIMP_TAC (srw_ss()) [] THEN1

(`i < SUC (LENGTH s1 + LENGTH s2)`by DECIDE_TAC THEN
RES_TAC THEN
`LENGTH (h::s1) = SUC (LENGTH s1)`by SRW_TAC [][] THEN
`EL i (h::s1) = EL i (h::(s1 ++ s2))` by METIS_TAC [EL_APPEND1, APPEND, 
						    APPEND_ASSOC] THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`rest`, `EL j (h::s1)`] MP_TAC) THEN SRW_TAC [][] THEN1
METIS_TAC [] THEN
`j < SUC (LENGTH s1)` by DECIDE_TAC THEN
 METIS_TAC [EL_APPEND1, APPEND, APPEND_ASSOC]) THEN

`LENGTH (h::s1) + i < SUC (LENGTH s1 + LENGTH s2)` 
 by FULL_SIMP_TAC (srw_ss()++ARITH_ss) [] THEN
RES_TAC THEN
`EL i s2 = EL (LENGTH (h::s1) + i) (h::(s1++s2))` 
 by METIS_TAC [elAppendList, APPEND,APPEND_ASSOC] THEN
SRW_TAC [][] THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`rest`,`EL j s2`] MP_TAC) THEN SRW_TAC [][] THEN
FULL_SIMP_TAC (srw_ss()) [] THEN
`j < SUC (LENGTH s1) + i` by DECIDE_TAC THEN
Q.EXISTS_TAC `LENGTH (h::s1) + j` THEN
SRW_TAC [][] THEN
`j < LENGTH s2` by DECIDE_TAC THEN
`EL j s2 = EL (LENGTH (h::s1) + j) (h::(s1++s2))` by
METIS_TAC [elAppendList, APPEND,APPEND_ASSOC] THEN
FULL_SIMP_TAC (srw_ss()) []);


val r49E_seenInv = store_thm
("r49E_seenInv",
``seenInv ru0 (sl0 ++ seen0) ⇒
noeProds ru0 ⇒
¬MEM ntk seen0 ⇒
r49Elem ntk (seen0,ru0,sl0) (seen,ru,sl) ⇒
seenInv ru (sl++seen)``,

SRW_TAC [][seenInv] THEN
FULL_SIMP_TAC (srw_ss()) [r49Elem] THEN 
SRW_TAC [][] THEN
FULL_SIMP_TAC (srw_ss()) [] THEN
`LENGTH sl0 + SUC (LENGTH seen) =  LENGTH sl0 + 1 + LENGTH seen` by DECIDE_TAC THEN
`rule (EL i (sl0 ++ [se] ++ seen)) (NTS nt::rest) ∈
 aProdAllRules ntk se NULL (set ru0)` by METIS_TAC [mem_in] THEN
FULL_SIMP_TAC (srw_ss()) [aProdAllRules_def, NULL_EQ_NIL,noeProds] THEN
SRW_TAC [][] THEN1
METIS_TAC [APPEND, APPEND_ASSOC] THEN1
METIS_TAC [APPEND, APPEND_ASSOC] THEN1
METIS_TAC [APPEND, APPEND_ASSOC] THEN
Cases_on `x` THEN FULL_SIMP_TAC (srw_ss()) [] THEN1
METIS_TAC [] THEN
SRW_TAC [][] THEN
`∀j. j ≤ i ⇒ EL j (sl0 ++ se::seen) ≠ se` 
 by METIS_TAC [APPEND, APPEND_ASSOC] THEN
`i ≤ LENGTH sl0` by MAGIC THEN
MAGIC);


val r49ERtc_seenInv = store_thm
("r49ERtc_seenInv",
``∀x y. (r49Elem ntk)^* x y ⇒ 
∀seen0 ru0 sl0. (x=(seen0,ru0,sl0)) ⇒ (y=(seen,ru,sl)) ⇒
seenInv ru0 (sl0 ++ seen0) ⇒
noeProds ru0 ⇒
¬MEM ntk seen0 ⇒
seenInv ru (sl++seen)``,

HO_MATCH_MP_TAC RTC_STRONG_INDUCT THEN SRW_TAC [][] THEN
`∃seen1 ru1 sl1. (x' = (seen1,ru1,sl1))` by MAGIC THEN
SRW_TAC [][] THEN
IMP_RES_TAC r49E_seenInv THEN
METIS_TAC [r49E_seenInv, r49E_noeProds, r49Elem, MEM]);


(***********************************************************************************)
(* STEP SEEN INV *)
(***********************************************************************************)

val stepSeen = Define
`stepSeen ru sl nt = 
∀nt' rst. rule nt (NTS nt'::rst) ∈ ru ⇒ ¬MEM nt' sl`;


val r49E_stepSeen = store_thm
("r49E_stepSeen",
``stepSeen ru0 sl0 ntk ⇒
seenInv ru0 (sl0 ++ seen0) ⇒
noeProds ru0 ⇒
r49Elem ntk (seen0,ru0,sl0) (seen,ru,sl) ⇒
stepSeen ru sl ntk``,

SRW_TAC [][stepSeen] THEN
FULL_SIMP_TAC (srw_ss()) [r49Elem] THEN
SRW_TAC [][] 
THENL[      
      `rule ntk (NTS nt'::rst) ∈ aProdAllRules ntk se NULL (set ru0)`
      by METIS_TAC [mem_in] THEN
      FULL_SIMP_TAC (srw_ss()) [aProdAllRules_def] THEN1
      METIS_TAC [] THEN
      FULL_SIMP_TAC (srw_ss()) [NULL_EQ_NIL, seenInv] THEN
      SRW_TAC [][] THEN
      FULL_SIMP_TAC (srw_ss()) [] THEN
      Cases_on `x` THEN FULL_SIMP_TAC (srw_ss()) [noeProds] THEN1
      METIS_TAC [] THEN
      SRW_TAC [][] THEN
      `EL (LENGTH sl0) (sl0++se::seen) = se` by MAGIC THEN
      FULL_SIMP_TAC (srw_ss()) [] THEN
      `LENGTH sl0 < LENGTH sl0 + SUC (LENGTH seen)` by DECIDE_TAC THEN
      `∀j. j ≤ (LENGTH sl0) ⇒ EL j (sl0 ++ se::seen) ≠ nt'`
      by METIS_TAC [symbol_11] THEN
      `LENGTH (sl0++se::seen) = LENGTH sl0 + SUC (LENGTH seen)` by
      FULL_SIMP_TAC (srw_ss()) [] THEN
      MAGIC,

      `rule ntk (NTS nt'::rst) ∈ aProdAllRules ntk se NULL (set ru0)`
      by METIS_TAC [mem_in] THEN
      FULL_SIMP_TAC (srw_ss()) [aProdAllRules_def] THEN
      FULL_SIMP_TAC (srw_ss()) [NULL_EQ_NIL] THEN1
      METIS_TAC [] THEN 
      SRW_TAC [][] THEN
      FULL_SIMP_TAC (srw_ss()) [] THEN
      Cases_on `x` THEN FULL_SIMP_TAC (srw_ss()) [noeProds] THEN1
      METIS_TAC [] THEN
      SRW_TAC [][] THEN
      FULL_SIMP_TAC (srw_ss()) [seenInv] THEN
      `LENGTH sl0 < LENGTH sl0 + SUC (LENGTH seen)` by DECIDE_TAC THEN
      `EL (LENGTH sl0) (sl0++se::seen) = se` by MAGIC THEN
      `∀j. j ≤ (LENGTH sl0) ⇒ EL j (sl0 ++ se::seen) ≠ nt'`
      by METIS_TAC [symbol_11] THEN
      `LENGTH (sl0++se::seen) = LENGTH sl0 + SUC (LENGTH seen)` by
      FULL_SIMP_TAC (srw_ss()) [] THEN
      `LENGTH sl0 ≤ LENGTH sl0` by SRW_TAC [][] THEN
      METIS_TAC []
      ]);
      

val r49ERtc_stepSeen = store_thm
("r49ERtc_stepSeen",
``∀x y. (r49Elem ntk)^* x y ⇒ 
∀seen0 ru0 sl0. (x=(seen0,ru0,sl0)) ⇒ (y=(seen,ru,sl)) ⇒
stepSeen ru0 sl0 ntk ⇒
¬MEM ntk seen0 ⇒
seenInv ru0 (sl0 ++ seen0) ⇒
noeProds ru0 ⇒
stepSeen ru sl ntk``,

HO_MATCH_MP_TAC RTC_STRONG_INDUCT THEN SRW_TAC [][] THEN
`∃seen1 ru1 sl1. (x' = (seen1,ru1,sl1))` by MAGIC THEN
SRW_TAC [][] THEN
IMP_RES_TAC r49E_stepSeen THEN
IMP_RES_TAC r49E_noeProds THEN
IMP_RES_TAC r49E_seenInv THEN
FULL_SIMP_TAC (srw_ss()) [] THEN
FULL_SIMP_TAC (srw_ss()) [r49Elem] THEN
SRW_TAC [][] THEN
METIS_TAC [MEM]);


(***********************************************************************************)
(* RHS TL INV *)
(***********************************************************************************)

val rhsTlNonTms = Define
`rhsTlNonTms ru ntsl bs = 
 (∀e. e ∈ (set ntsl DIFF set bs) ⇒
  (∀r.MEM (rule e r) ru ⇒ 
   ∃h t.(r = h::t) ∧ EVERY isNonTmnlSym t ∧ (isNonTmnlSym h ⇒ t ≠ [])))`;

val r49E_rhsTlNonTms = store_thm
("r49E_rhsTlNonTms",
``rhsTlNonTms ru0 (ntms (G ru0 s)) bs ⇒
(set seen0 ∩ set bs = {}) ⇒
r49Elem ntk (seen0,ru0,sl0) (seen,ru,sl) ⇒
rhsTlNonTms ru (ntms (G r s)) bs``,

SRW_TAC [][rhsTlNonTms] THEN
FULL_SIMP_TAC (srw_ss()) [r49Elem] THEN
SRW_TAC [][] THEN
`rule e r' ∈ aProdAllRules ntk se NULL (set ru0)` by METIS_TAC [mem_in] THEN
FULL_SIMP_TAC (srw_ss()) [aProdAllRules_def, NULL_EQ_NIL] THEN
SRW_TAC [][] THEN1
METIS_TAC [slemma1_4, ntmsMem, startSym_def, rules_def] THEN
`¬MEM se bs` by (FULL_SIMP_TAC (srw_ss()) [EXTENSION] THEN
		METIS_TAC []) THEN
`e ∈ ntms (G ru0 s)` by METIS_TAC [slemma1_4, ntmsMem, startSym_def,rules_def] THEN
RES_TAC THEN FULL_SIMP_TAC (srw_ss()) [] THEN
SRW_TAC [][] THEN
FULL_SIMP_TAC (srw_ss()) [isNonTmnlSym_def] THEN
`se ∈ ntms (G ru0 s)` by METIS_TAC [slemma1_4, ntmsMem, startSym_def,rules_def] THEN
RES_TAC THEN FULL_SIMP_TAC (srw_ss()) [] THEN
SRW_TAC [][]);

val r49ERtc_rhsTlNonTms = store_thm
("r49ERtc_rhsTlNonTms",
``∀x y. (r49Elem ntk)^* x y ⇒ 
∀seen0 ru0 sl0. (x=(seen0,ru0,sl0)) ⇒ (y=(seen,ru,sl)) ⇒
rhsTlNonTms ru0 (ntms (G ru0 s)) bs ⇒
(set seen0 ∩ set bs = {}) ⇒
rhsTlNonTms ru (ntms (G ru s)) bs``,

HO_MATCH_MP_TAC RTC_STRONG_INDUCT THEN SRW_TAC [][] THEN
`∃seen1 ru1 sl1. (x' = (seen1,ru1,sl1))` by MAGIC THEN
SRW_TAC [][] THEN
 `∃se. (seen0 = se::seen1) ∧ (sl1 = sl0 ++ [se])` by METIS_TAC [r49Elem] THEN
`(set seen1 ∩ set bs = {})` by (FULL_SIMP_TAC (srw_ss()) [EXTENSION] THEN
				METIS_TAC []) THEN
METIS_TAC [r49E_rhsTlNonTms, startSym_def, rules_def]);


(***********************************************************************************)
(* RULES SAME INV *)
(***********************************************************************************)

val rulesSame = Define
`rulesSame ru ntsl ubs =
∀e. MEM e ntsl ⇒ ∀r. MEM (rule e r) ru ⇒ ∀nt. MEM (NTS nt) r ⇒ ¬MEM nt ubs`;


(***********************************************************************************)
(* RHS B NONTMS INV *)
(***********************************************************************************)

val rhsBNonTms = Define
`rhsBNonTms ru ubs = 
 (∀B. MEM B ubs ⇒ 
  ∀r. MEM (rule B r) ru ⇒ 
  EVERY isNonTmnlSym r  ∧ r ≠ [] ∧ ∃nt.(HD r = NTS nt) ∧ ¬MEM nt ubs)`;


val r49E_rhsBNonTms = store_thm
("r49E_rhsBNonTms",
``¬MEM ntk (seen0 ++ bs ++ ubs) ⇒
 rhsBNonTms ru0 ubs ⇒
 r49Elem ntk (seen0,ru0,sl0) (seen,ru,sl) ⇒
 rhsBNonTms ru ubs``,

SRW_TAC [][rhsBNonTms] THEN
FULL_SIMP_TAC (srw_ss()) [r49Elem] THEN
SRW_TAC [][] THEN
`rule B r ∈ aProdAllRules ntk se NULL (set ru0)` by METIS_TAC [mem_in] THEN
FULL_SIMP_TAC (srw_ss()) [aProdAllRules_def, NULL_EQ_NIL, EXTENSION] THEN
FULL_SIMP_TAC (srw_ss()) [rhsTlNonTms] THEN
SRW_TAC [][] THEN1
METIS_TAC [] THEN
METIS_TAC []);

val r49ERtc_rhsBNonTms = store_thm
("r49ERtc_rhsBNonTms",
``∀x y. (r49Elem ntk)^* x y ⇒ 
∀seen0 ru0 sl0. (x=(seen0,ru0,sl0)) ⇒ (y=(seen,ru,sl)) ⇒
 ¬MEM ntk (seen0 ++ bs ++ ubs) ⇒
 rhsBNonTms ru0 ubs ⇒
 rhsBNonTms ru ubs``,

HO_MATCH_MP_TAC RTC_STRONG_INDUCT THEN SRW_TAC [][] THEN
`∃seen1 ru1 sl1. (x' = (seen1,ru1,sl1))` by MAGIC THEN
SRW_TAC [][] THEN
 `∃se. (seen0 = se::seen1) ∧ (sl1 = sl0 ++ [se])` by METIS_TAC [r49Elem] THEN
SRW_TAC [][] THEN
METIS_TAC [r49E_rhsBNonTms, MEM, MEM_APPEND]);


(***********************************************************************************)
(* r49Elem Existence *)
(***********************************************************************************)


val r49E_exists = store_thm
("r49E_exists",
``∃u. r49Elem ntk (se::seen0,ru0,sl0) u ∧
∃ru.(u = (seen0,ru,sl0++[se])) ``,

SRW_TAC [][] THEN
Q.ABBREV_TAC `ru = aProdAllRules ntk se NULL (set ru0)` THEN
`FINITE ru` by METIS_TAC [FINITE_LIST_TO_SET, finiteaProdAllRules] THEN
`∃r.set r = ru` by METIS_TAC [listExists4Set] THEN
Q.EXISTS_TAC `(seen0,r,sl0++[se])` THEN
SRW_TAC [][r49Elem] THEN
UNABBREV_ALL_TAC THEN
FULL_SIMP_TAC (srw_ss()) [EXTENSION]);

val r49ERtc_exists = store_thm
("r49ERtc_exists",
 ``∀seen0 ru0 sl0. 
 ∃ru. (r49Elem ntk)^* (seen0,ru0,sl0) ([],ru,sl0++seen0)``,

Induct_on `seen0` THEN SRW_TAC [][] THEN1
METIS_TAC [RTC_RULES] THEN
`∃u. r49Elem ntk (h::seen0,ru0,sl0) u ∧
 ∃ru.(u = (seen0,ru,sl0++[h]))` by METIS_TAC [r49E_exists] THEN
SRW_TAC [][] THEN
SRW_TAC [][Once RTC_CASES1] THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`ru`,`sl0++[h]`] MP_TAC) THEN SRW_TAC [][] THEN
MAP_EVERY Q.EXISTS_TAC [`ru'`,`(seen0,ru,sl0 ++ [h])`] THEN
METIS_TAC [APPEND, APPEND_ASSOC]);

(***********************************************************************************)
(* r49Elem Language Equivalence *)
(***********************************************************************************)

val r49E_equiv = store_thm
("r49E_equiv",
``¬MEM ntk seen0 ⇒ r49Elem ntk (seen0,ru0,sl0) (seen,ru,sl) ⇒
 (language (G ru0 s) = language (G ru s))``,

SRW_TAC [][r49Elem] THEN
METIS_TAC [lemma4_3all, aProdgAll_def, rulesets_the_same, startSym_def,
	   rules_def, MEM]);


val r49ERtc_equiv = store_thm
("r49ERtc_equiv",
``∀x y.(r49Elem ntk)^* x y ⇒ 
∀seen0 ru0 sl0. (x=(seen0,ru0,sl0)) ⇒ (y=(seen,ru,sl)) ⇒
 ¬MEM ntk seen0 ⇒
 (language (G ru0 s) = language (G ru s))``,

HO_MATCH_MP_TAC RTC_STRONG_INDUCT THEN SRW_TAC [][] THEN
`∃seen1 ru1 sl1. (x' = (seen1,ru1,sl1))` by MAGIC THEN
SRW_TAC [][] THEN
METIS_TAC [r49E_equiv, startSym_def, rules_def, rulesets_the_same, r49Elem,MEM]);

(***********************************************************************************)
(* R49 using r49Elem *)
(***********************************************************************************)

val r49 = Define
`r49 (bs0: α list, nts0: α list, g0:(α,β) grammar, seen0: α list, ubs0)
       (bs,nts,g,seen, ubs) =

∃ntk b.(nts0 = ntk::nts) ∧ (bs0 = b::bs) ∧ (ubs = ubs0 ++ [b]) ∧
(seen = seen0 ++ [ntk]) ∧ (nts = TL nts0) ∧

∃rules0. (r49Elem ntk)^* (seen0,(rules g0),[]) ([],rules0,seen0) ∧

∃rules1. (rules1 = l2rRules ntk b (set rules0)) ∧

(startSym g = startSym g0) ∧ (set (rules g) = rules1)`;

(***********************************************************************************)
(* R49 Language equivalence *)
(***********************************************************************************)

val r49_equiv = prove
    (``∀g0 s0 nts0 b.
     ¬MEM b (ntms g0) ⇒
     (set nts0 ∩ set s0 = {}) ⇒
     ∀bs nts g s.
     r49 (b::bs0,nts0,g0,s0,ubs0) (bs,nts,g,s,ubs) ⇒
     (language g0 = language g)``,

SRW_TAC [][r49] THEN
`FINITE (aProdAllRules ntk se NULL (set (rules g0)))`
by METIS_TAC [FINITE_LIST_TO_SET, finiteaProdsRules] THEN
`∃r. set r = aProdsRules ntk s0 NULL (set (rules g0))` 
 by METIS_TAC [listExists4Set] THEN

`aProds ntk s0 NULL g0 (G r (startSym g0))` by

(SRW_TAC [][aProds_def, startSym_def, rules_def] THEN1
 
 (FULL_SIMP_TAC (srw_ss()) [INTER_DEF, EXTENSION] THEN
  METIS_TAC [MEM]) THEN

 FULL_SIMP_TAC (srw_ss()) [EXTENSION]) THEN
 
`language (G r (startSym g0)) = language g0` by METIS_TAC [lemma4_3Gen] THEN

 `∃r'. set r' = l2rRules ntk b
 (aProdsRules ntk s0 NULL (set (rules g0)))` 
 by METIS_TAC [listExists4Set, finitel2rRules] THEN


`left2Right ntk b (G r (startSym g0)) (G r' (startSym g0))`
     by (SRW_TAC [][startSym_def, rules_def, left2Right_def] THEN
	 METIS_TAC [bNotInaProds]) THEN
`language (G r (startSym g0)) = language (G r'(startSym g0))` by
METIS_TAC [lemma4_4] THEN
METIS_TAC [rulesets_the_same, startSym_def, rules_def]);

val r49Rtc_equiv = store_thm
("r49Rtc_equiv",
``∀s0 s.RTC r49 s0 s ⇒ 
 ∀bs0 nts0 g0 seen0 ubs0.(s0=(bs0,nts0,g0,seen0,ubs0)) ⇒
 (s = (bs,nts,g,seen,ubs)) ⇒
 LENGTH bs0 ≥ LENGTH nts0 ∧ ALL_DISTINCT bs0 ∧ 
 ALL_DISTINCT nts0 ∧
 (set (ntms g0) ∩ set bs0 = {}) ⇒
 (set nts0 ∩ set seen0 = {}) ⇒
 (language g0 = language g)``,
 
HO_MATCH_MP_TAC RTC_STRONG_INDUCT THEN
SRW_TAC [][] THEN
`∃bs0' nts' g' seen' ubs'.(s0' = (bs',nts',g',seen', ubs'))` by MAGIC THEN
SRW_TAC [][] THEN
`∃ntk b.
 (nts0 = ntk::nts') ∧ (bs0 = b::bs') ∧ (ubs' = ubs0 ++ [b]) ∧
 (seen' = seen0 ++ [ntk]) ∧ (nts' = TL nts0)` by METIS_TAC [r49] THEN
SRW_TAC [][] THEN
`LENGTH bs'  ≥ LENGTH (TL nts0)` by
(Cases_on `nts0` THEN FULL_SIMP_TAC (srw_ss()++ARITH_ss) []) THEN
`(set (TL nts0) ∩ set (seen0 ++ [ntk]) = {})` by MAGIC THEN
`ALL_DISTINCT (TL nts0)` by METIS_TAC [ALL_DISTINCT_APPEND, APPEND] THEN
`set (ntms g') ⊆ set (ntms g0) ∪ {b}` by METIS_TAC [r49_ntmsSubsetSing] THEN
FULL_SIMP_TAC (srw_ss()) [] THEN
`(set (ntms g') ∩ set bs' = {})` 
by (FULL_SIMP_TAC (srw_ss()) [EXTENSION, SUBSET_DEF] THEN
    METIS_TAC []) THEN
`ALL_DISTINCT bs'` by METIS_TAC [APPEND, ALL_DISTINCT_APPEND] THEN
RES_TAC THEN
`¬MEM b (ntms g0)` by (FULL_SIMP_TAC (srw_ss()) [SUBSET_DEF, EXTENSION] THEN
		       METIS_TAC []) THEN
METIS_TAC [r49_equiv, MEM]);

(***********************************************************************************)
(* R49 Existence *)
(***********************************************************************************)

val r49_exists = store_thm
("r49_exists",
``∃u.r49 (b::t',ntk::t,g0,seen0,ubs0) u ∧ 
 ∃g.(u = (t',t,g,seen0++[ntk],ubs0++[b]))``,

SRW_TAC [][] THEN
Q.ABBREV_TAC `rules0' = aProdsRules ntk seen0 NULL (set (rules g0))` THEN
`FINITE rules0'`
by METIS_TAC [FINITE_LIST_TO_SET, finiteaProdsRules] THEN
`∃r.set r = rules0'` 
 by METIS_TAC [listExists4Set] THEN
 `∃r'. set r' = l2rRules ntk b rules0'` 
 by METIS_TAC [listExists4Set, finitel2rRules] THEN
Q.EXISTS_TAC `(t',t,(G r' (startSym g0)),seen0++[ntk],ubs0++[b])` THEN
SRW_TAC [][r49, startSym_def, rules_def, LET_THM] THEN
UNABBREV_ALL_TAC THEN
FULL_SIMP_TAC (srw_ss()) [EXTENSION]);


val r49Rtc_exists = store_thm
("r49Rtc_exists",
``∀nts0 bs0.
 LENGTH bs0 ≥ LENGTH nts0 ⇒ 
 ALL_DISTINCT bs0 ∧ ALL_DISTINCT nts0 ⇒
 ∀seen0.(set nts0 ∩ set seen0 = {} ) ⇒
 ∀g0.(set (ntms g0) ∩ set bs0 = {}) ⇒
 ∃g n.(r49)^* (bs0, nts0, g0, seen0,[]) 
 (DROP n bs0 ,[],g,seen0++nts0,TAKE n bs0)``,

Induct_on `LENGTH nts0` THEN SRW_TAC [][] THEN1
(`nts0 = []` by METIS_TAC [LENGTH_NIL] THEN
 FULL_SIMP_TAC (srw_ss()) [] THEN
 SRW_TAC [][] THEN
 MAP_EVERY Q.EXISTS_TAC [`g0`,`0`] THEN
 SRW_TAC [][]) THEN

Cases_on `nts0` THEN SRW_TAC [][] THEN
FULL_SIMP_TAC (srw_ss()) [] THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`t`] MP_TAC) THEN SRW_TAC [][] THEN
Cases_on `bs0` THEN FULL_SIMP_TAC (srw_ss()) [] THEN1
FULL_SIMP_TAC (arith_ss) [] THEN
`LENGTH t' ≥ LENGTH t` by DECIDE_TAC THEN
`ALL_DISTINCT (t' ++ [h'])` by SRW_TAC [][ALL_DISTINCT_APPEND] THEN
`∃u. r49 (h'::t',h::t,g0,seen0, ubs0) u ∧
 ∃g. u = (t',t,g,seen0++[h],ubs0++[h'])` by METIS_TAC [APPEND, r49_exists] THEN
SRW_TAC [][] THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`t'`] MP_TAC) THEN SRW_TAC [][] THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`seen0++[h]`] MP_TAC) THEN SRW_TAC [][] THEN
`(set t ∩ (set seen0 ∪ {h}) = {})` by
(FULL_SIMP_TAC (srw_ss()) [INTER_DEF, EXTENSION] THEN
 METIS_TAC []) THEN
FULL_SIMP_TAC (srw_ss()) [] THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`g`] MP_TAC) THEN SRW_TAC [][] THEN
`set (ntms g) ⊆ set (ntms g0) ∪ {h'}` by METIS_TAC [r49_ntmsSubsetSing] THEN
FULL_SIMP_TAC (srw_ss()) [] THEN
`(set (ntms g) ∩ set t' = {})` 
by (FULL_SIMP_TAC (srw_ss()) [EXTENSION, SUBSET_DEF] THEN
    METIS_TAC []) THEN
FULL_SIMP_TAC (srw_ss()) [] THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`ubs0++[h']`] MP_TAC) THEN SRW_TAC [][] THEN
SRW_TAC [][Once RTC_CASES1] THEN
MAP_EVERY Q.EXISTS_TAC [`g'`,`SUC n`,`(t',t,g,seen0 ++ [h],ubs0 ++ [h'])`] THEN
SRW_TAC [][] THEN
METIS_TAC [APPEND, APPEND_ASSOC]);

(***********************************************************************************)
(* Invariants *)
(***********************************************************************************)

val r49_seenInv = prove
(``∀s0 g0 nts0 bs0. 
 seenInv (rules g0) s0 ∧ 
 noeProds (rules g0) ∧
 (set nts0 ∩ set s0 = {}) ∧ 
 (set (ntms g0) ∩ set bs0 = {}) ⇒
 ∀bs0 ubs0 bs nts g s ubs.
 r49 (bs0,nts0,g0,s0,ubs0) (bs,nts,g,s,ubs) ⇒
 seenInv (rules g) s``,

SRW_TAC [][r49] THEN
`FINITE (aProdsRules ntk s0 NULL (set (rules g0)))`
by METIS_TAC [FINITE_LIST_TO_SET, finiteaProdsRules] THEN
`∃r.set r =  aProdsRules ntk s0 NULL (set (rules g0))` 
 by METIS_TAC [listExists4Set] THEN
`seenInv r s0` by
(SRW_TAC [][seenInv,aProdsRules_def] THEN
 FULL_SIMP_TAC (srw_ss()) [rules_def,seenInv] THEN
 `rule (EL i s0) (NTS nt::rest) ∈ aProdsRules ntk s0 NULL (set (rules g0))`
 by METIS_TAC [mem_in] THEN
 FULL_SIMP_TAC (srw_ss()) [aProdsRules_def] THEN
 SRW_TAC [][] THEN
 `EL i s0 ∈ set s0` by METIS_TAC [MEM_EL, mem_in] THEN
 FULL_SIMP_TAC (srw_ss()) [INTER_DEF, EXTENSION] THEN
 METIS_TAC [MEM]) THEN

`∀i. i < LENGTH s0 ⇒
 (∀nt rest. rule ntk (NTS nt::rest) ∈ aProdsRules ntk s0 NULL (set (rules g0)) 
  ⇒ EL i s0 ≠ nt)` by 
 (SRW_TAC [][aProdsRules_def] THEN
  FULL_SIMP_TAC (srw_ss()) [seenInv] THEN1
  (SPOSE_NOT_THEN ASSUME_TAC THEN
   FULL_SIMP_TAC (srw_ss()) [] THEN
   SRW_TAC [][] THEN
   METIS_TAC [EL_IS_EL, NULL_EQ_NIL, APPEND_NIL, APPEND, APPEND_ASSOC]) THEN
  
  SPOSE_NOT_THEN ASSUME_TAC THEN SRW_TAC [][] THEN
  Cases_on `p` THEN FULL_SIMP_TAC (srw_ss()) [] THEN
  Cases_on `x` THEN FULL_SIMP_TAC (srw_ss()) [noeProds] THEN1
  METIS_TAC [] THEN
  SRW_TAC [][] THEN
  MAGIC) THEN

 `∃r'. set r' = l2rRules ntk b
 (aProdsRules ntk s0 NULL (set (rules g0)))` 
 by METIS_TAC [listExists4Set, finitel2rRules] THEN

`seenInv r' (s0 ++ [ntk])` by

(FULL_SIMP_TAC (srw_ss()) [seenInv, rules_def,l2rRules_def, newAprods_def, 
			   bprods_def] THEN 
 SRW_TAC [][] THEN1

(`i < LENGTH s0 ∨ (i = LENGTH s0)` by DECIDE_TAC THEN1
 (`EL j (s0++[ntk]) = EL j s0` by METIS_TAC [EL_APPEND1, DECIDE ``i < l ∧ j ≤ i
					    ⇒ j < l``] THEN
 `EL i (s0++[ntk]) = EL i s0` by METIS_TAC [EL_APPEND1, DECIDE ``i < l ∧ j ≤ i
					    ⇒ j < l``] THEN
  METIS_TAC []) THEN
`EL i (s0 ++ [ntk]) = ntk` by METIS_TAC [EL_LENGTH_APPEND, NULL_EQ_NIL, HD,
					 NOT_CONS_NIL,CONS] THEN
SRW_TAC [][] THEN
`EL (LENGTH s0) (s0++[ntk]) = ntk` by METIS_TAC [EL_LENGTH_APPEND, NULL_EQ_NIL, HD,
					 NOT_CONS_NIL,CONS] THEN
SRW_TAC [][] THEN
FULL_SIMP_TAC (srw_ss()) [] THEN
`j < LENGTH s0 ∨ (j = LENGTH s0)`by DECIDE_TAC THEN1
(`EL j (s0 ++ [ntk]) = EL j s0` by METIS_TAC [EL_APPEND1, DECIDE ``i < l ∧ j ≤ i
					    ⇒ j < l``] THEN METIS_TAC []) THEN
FULL_SIMP_TAC (srw_ss()) [recprods_def] THEN
METIS_TAC []) THEN
MAGIC) THEN

FULL_SIMP_TAC (srw_ss()) [seenInv, LET_THM] THEN
SRW_TAC [][] THEN
METIS_TAC [mem_in]);


val r49Rtc_seenInv = store_thm
("r49Rtc_seenInv",
 ``∀x y. (r49)^* x y ⇒ 
 ∀bs0 nts0 g0 s0 ubs0. (x = (bs0,nts0,g0,s0,ubs0)) ⇒ (y= (bs,nts,g,s,ubs)) ⇒
 seenInv (rules g0) s0 ∧ (set nts0 ∩ set s0 = {}) ∧ 
 (set (ntms g0) ∩ set bs0 = {})
 ⇒
 seenInv (rules g) s``,

HO_MATCH_MP_TAC RTC_STRONG_INDUCT THEN SRW_TAC [][] THEN
`∃bs1 nts1 g1 s1 ubs1. (x' = (bs1, nts1, g1, s1,ubs1))`by MAGIC THEN
SRW_TAC [][] THEN
`seenInv (rules g1) s1` by METIS_TAC [r49_seenInv] THEN
`∃ntk b. (nts0 = ntk::nts1) ∧ (bs0 = b::bs1) ∧
 (s1 = s0 ++ [ntk]) ∧ (nts1 = TL nts0)` by METIS_TAC [r49] THEN
SRW_TAC [][] THEN

`(set (TL nts0) ∩ set (s0 ++ [ntk]) = {})` by MAGIC THEN
 `(set (ntms g1) ∩ set bs1 = {})` by MAGIC THEN
METIS_TAC []);


(***********************************************************************************)
(* Transforming the head ntm to a tm symbol. *)
(***********************************************************************************)

val isCnfImprhsTlNonTmnls = store_thm
("isCnfImprhsTlNonTmnls",
``isCnf g0 ⇒ (set (ntms g0) ∩ set bs0 = {}) ⇒
 rhsTlNonTms (rules g0) (ntms g0) bs0``,

SRW_TAC [][isCnf_def, rhsTlNonTms] THEN
RES_TAC 
 THENL[
       Cases_on `r` THEN FULL_SIMP_TAC (srw_ss()) [] THEN
       Cases_on `h` THEN FULL_SIMP_TAC (srw_ss()) [isNonTmnlSym_def, isTmnlSym_def] THEN
       METIS_TAC [LENGTH_NIL, EVERY_DEF, DECIDE ``1 ≠ 0``],

       Cases_on `r` THEN FULL_SIMP_TAC (srw_ss()) [] THEN
       Cases_on `h` THEN FULL_SIMP_TAC (srw_ss()) [isNonTmnlSym_def, isTmnlSym_def] THEN
       METIS_TAC [LENGTH_NIL, EVERY_DEF, DECIDE ``1 ≠ 0``],

       FULL_SIMP_TAC (srw_ss()) [EXTENSION] THEN
       METIS_TAC [ntmsMem, slemma1_4],

       Cases_on `r` THEN FULL_SIMP_TAC (srw_ss()) [] THEN
       Cases_on `h` THEN FULL_SIMP_TAC (srw_ss()) [isNonTmnlSym_def, isTmnlSym_def] THEN
       METIS_TAC [LENGTH_NIL, EVERY_DEF, DECIDE ``1 ≠ 0``],

       FULL_SIMP_TAC (srw_ss()) [EXTENSION] THEN
       METIS_TAC [ntmsMem, slemma1_4],

       Cases_on `r` THEN FULL_SIMP_TAC (srw_ss()) [] THEN
       Cases_on `h` THEN FULL_SIMP_TAC (srw_ss()) [isNonTmnlSym_def] THEN
       FULL_SIMP_TAC (srw_ss()) [EXTENSION] THEN
       METIS_TAC [ntmsMem, slemma1_4, APPEND, APPEND_NIL],

       Cases_on `r` THEN FULL_SIMP_TAC (srw_ss()) [] THEN
       Cases_on `h` THEN FULL_SIMP_TAC (srw_ss()) [isNonTmnlSym_def, 
						   isTmnlSym_def] THEN
       FULL_SIMP_TAC (srw_ss()) [EXTENSION] THEN
       METIS_TAC [ntmsMem, slemma1_4, APPEND, APPEND_NIL]       
       ]);



val validGnfProd = Define 
`validGnfProd (rule l r) = 
    ∃ts ntsl.(r = ts::ntsl) ∧ isTmnlSym ts ∧ EVERY isNonTmnlSym ntsl`;

val isGnf = Define 
`isGnf g = EVERY validGnfProd (rules g)`;


val fstNtm2Tm = Define
`fstNtm2Tm (ontms0,g0,seen0) (ontms,g,seen) = 
∃ntj.
(ontms0 = ontms++[ntj]) ∧
(seen = ntj::seen0) ∧
(set (rules g) = 
 set (rules g0) DIFF
 {rule ntj ([NTS ntk] ++ s) |
  (ntk,s) | ntk ∈ seen0 ∧ rule ntj ([NTS ntk] ++ s) ∈ (set (rules g0))} ∪
 {rule ntj (x ++ s) | (x,s) |
  ∃ntk. ntk ∈ seen0 ∧ rule ntj ([NTS ntk] ++ s) ∈ (set (rules g0)) ∧
  rule ntk x ∈ (set (rules g0)) ∧ validGnfProd (rule ntk x) }) ∧
(startSym g0 = startSym g)`;

val gnfInv = Define
`gnfInv ru s = 
∀i. i < LENGTH s ⇒
∀r. rule (EL i s) r ∈ ru ⇒ validGnfProd (rule (EL i s) r)`;

(*
``gnfInv (rules g0) s0 ⇒
 (ntsl g0 = REVERSE (ontms0 ++ s0)) ⇒
(* seenInv (rules g0) (ntsl g0) ⇒*)
 fstNtm2Tm (ontms0,g0,s0) (ontms,g,s) ⇒
 gnfInv (rules g) s``,
*)

val ruleInv = Define
`ruleInv ru ontms s =
     ∀i.
     i < LENGTH ontms ⇒
     ∀nt rst. rule (EL i ontms) (NTS nt::rst) ∈ ru ⇒ nt ∈ (DROP i ontms ++ s)`;


val fstNtm2Tm_gnfInv = store_thm
("fstNtm2Tm_gnfInv",
`` ALL_DISTINCT (ontms0 ++ s0) ⇒
 rhsTlNonTms (rules g0) ⇒
 seenInv (rules g0) ontms0 ⇒
 ruleInv (rules g0) ontms0 s0 ⇒
 gnfInv (rules g0) s0 ⇒
 fstNtm2Tm (ontms0,g0,s0) (ontms,g,s) ⇒
 gnfInv (rules g) s``,

SRW_TAC [][fstNtm2Tm] THEN
FULL_SIMP_TAC (srw_ss()) [gnfInv] THEN
SRW_TAC [][] THEN
`rule (EL i (ntj::s0)) r ∈
set (rules g0) DIFF
      {rule ntj (NTS ntk::s) |
       (ntk,s) |
       ntk ∈ s0 ∧ rule ntj (NTS ntk::s) ∈ rules g0} ∪
      {rule ntj (x ++ s) |
       (x,s) |
       ∃ntk.
         ntk ∈ s0 ∧ rule ntj (NTS ntk::s) ∈ rules g0 ∧
         rule ntk x ∈ rules g0 ∧ validGnfProd (rule ntk x)}`
 by METIS_TAC [mem_in] THEN
FULL_SIMP_TAC (srw_ss()) [validGnfProd]
 THENL[


       `i < LENGTH s0 ∨ (i = LENGTH s0)`by DECIDE_TAC THEN
       MAGIC,

       MAGIC
       ]);



val fstNtm2Tm_ruleInv = store_thm
("fstNtm2Tm_ruleInv",
``ALL_DISTINCT (ontms0 ++ s0) ⇒
 rhsTlNonTms (rules g0) ⇒
 seenInv (rules g0) ontms0 ⇒
 ruleInv (rules g0) ontms0 s0 ⇒
 gnfInv (rules g0) s0 ⇒
 fstNtm2Tm (ontms0,g0,s0) (ontms,g,s) ⇒
 ruleInv (rules g) ontms s``,

SRW_TAC [][fstNtm2Tm] THEN
FULL_SIMP_TAC (srw_ss()) [ruleInv] THEN
SRW_TAC [][] THEN

`i < LENGTH ontms + 1` by DECIDE_TAC THEN
`rule (EL i (s0 ++ [ntj])) (NTS nt::rst) ∈ 
set (rules g0) DIFF
      {rule ntj (NTS ntk::s) |
       (ntk,s) |
       ntk ∈ s0 ∧ rule ntj (NTS ntk::s) ∈ rules g0} ∪
      {rule ntj (x ++ s) |
       (x,s) |
       ∃ntk.
         ntk ∈ s0 ∧ rule ntj (NTS ntk::s) ∈ rules g0 ∧
         rule ntk x ∈ rules g0 ∧ validGnfProd (rule ntk x)}`
 by METIS_TAC [mem_in] THEN
FULL_SIMP_TAC (srw_ss()) [] 
THENL
 [
  `i < LENGTH s0` by MAGIC THEN
  `EL i (s0 ++ [ntj]) = EL i s0` by MAGIC THEN
  FULL_SIMP_TAC (srw_ss()) [] THEN
  MAGIC,

  
  MAGIC,

  MAGIC,

  MAGIC
  ]);


val fstNtm2Tm_equiv = store_thm
("fstNtm2Tm_equiv",
``ALL_DISTINCT (ontms0 ++ s0) ⇒
 (* rhsTlNonTms (rules g0) ⇒
 seenInv (rules g0) ontms0 ⇒
 ruleInv (rules g0) ontms0 s0 ⇒ *)
 gnfInv (rules g0) s0 ⇒ 
 fstNtm2Tm (ontms0,g0,s0) (ontms,g,s) ⇒
 (language g0 = language g)``,

MAGIC);

val fstNtm2Tm_exists = store_thm
("fstNtm2Tm_exists",
 ``∃g. fstNtm2Tm (ontms++[ntj],g0,s0) (ontms,g,ntj::s0)``,

 SRW_TAC [][fstNtm2Tm] THEN
Q.ABBREV_TAC `r = set (rules g0) DIFF
   {rule ntj (NTS ntk::s) |
    (ntk,s) |
    ntk ∈ s0 ∧ rule ntj (NTS ntk::s) ∈ rules g0} ∪
   {rule ntj (x ++ s) |
    (x,s) |
    ∃ntk.
      ntk ∈ s0 ∧ rule ntj (NTS ntk::s) ∈ rules g0 ∧
      rule ntk x ∈ rules g0 ∧ validGnfProd (rule ntk x)}` THEN
`FINITE r` by MAGIC THEN
`∃rl.∀e. MEM e rl ⇔ e ∈ r` by METIS_TAC [listExists4Set] THEN

Q.EXISTS_TAC `(G rl (startSym g0))` THEN
SRW_TAC [][r49, startSym_def, rules_def, LET_THM] THEN
UNABBREV_ALL_TAC THEN
FULL_SIMP_TAC (srw_ss()) [EXTENSION]);

val fstNtm2TmRtc_exists = store_thm
("fstNtm2TmRtc_exists",
 ``∀ontms0 g0 s0.
 ∃g. (fstNtm2Tm)^* (ontms0,g0,s0) ([],g,ontms0++s0)``,

HO_MATCH_MP_TAC SNOC_INDUCT THEN SRW_TAC [][SNOC_APPEND] THEN1
METIS_TAC [RTC_RULES] THEN
SRW_TAC [][Once RTC_CASES1] THEN

`∃g. fstNtm2Tm (ontms0 ++ [x],g0,s0) (ontms0,g,x::s0)` by METIS_TAC [fstNtm2Tm_exists] THEN
FIRST_X_ASSUM (Q.SPECL_THEN [`g`,`x::s0`] MP_TAC) THEN SRW_TAC [][] THEN
Q.EXISTS_TAC `g'` THEN
Q.EXISTS_TAC `(ontms0,g,x::s0)` THEN
METIS_TAC [APPEND_ASSOC, APPEND]);


val fstNtm2TmRtcLangEq = store_thm
("fstNtm2TmRtcLangEq",
``(fstNtm2Tm)^* (ontms0,g0,s0) (ontms,g,s) ⇒ (language g0 = language g)``,

MAGIC);


val ugImpcnf = store_thm
("ugImpcnf",
 ``usefulnts g0 g1 ∧ isCnf g0 ⇒ isCnf g1``,

Cases_on `g0` THEN
SRW_TAC [][usefulnts_def, startSym_def, rules_def] THEN
FULL_SIMP_TAC (srw_ss()) [isCnf_def, rules_def] THEN
SRW_TAC [][] THEN
METIS_TAC []);

val gnfExists = store_thm
("gnfExists",
``∀g:('a, 'b) grammar. 
 INFINITE (UNIV:'a set) ∧ 
 [] ∉ language g ∧
 language g ≠ {}  ⇒ 
 ∃g'.isGnf g' ∧ (language g = language g')``,

SRW_TAC [][] THEN
`∃cg. isCnf cg ∧ (language g = language cg)` by METIS_TAC [cnfisCnfEq, thm4_5,
							    eqLang_def] THEN
 `∃ug. usefulnts cg ug ∧ (language cg = language ug)` by
METIS_TAC [use_exists, lemma4_1a] THEN
`isCnf ug` by METIS_TAC [ugImpcnf] THEN
`ALL_DISTINCT (ntms ug)` by MAGIC THEN
 `∃bs0.ALL_DISTINCT bs0 ∧ (LENGTH bs0 ≥ LENGTH (ntms ug)) ∧
 (set (ntms ug) ∩ set bs0 = {})` by MAGIC THEN

`set (ntms ug) ∩ set ([]:'a list) = {}` by MAGIC THEN

`seenInv (rules ug) ([]:'a list)` by SRW_TAC [][seenInv] THEN

`(∀e. e ∈ bs0 ⇒ ¬(e ∈ ntms ug))` by MAGIC THEN


`∃g1.(r49)^* (bs0, ntms ug, ug, ([]:'a list)) 
			   (DROP (LENGTH (ntms ug)) bs0, ([]:'a list), g1,ntms ug) ∧
			   (language ug = language g1)`
 by METIS_TAC [r49RtcExists, rtcr49RtcLangeq, APPEND_NIL] THEN

`seenInv (rules g1) (ntms ug)` by METIS_TAC [r49Rtc_seenInv] THEN

`rhsTlNonTms (rules ug)` by METIS_TAC [isCnfImprhsTlNonTmnls] THEN

`rhsTlNonTms (rules g1)` by METIS_TAC [rhsTlNtmsRtc] THEN

`∀nt. nt ∈ (ntms ug) ⇒ gaw ug (NTS nt)` by METIS_TAC [lemma4_1,
						      ntmsMem] THEN

`∀nt. nt ∈ (ntms g1) ⇒ gaw g1 (NTS nt)` by METIS_TAC [r49Rtc_usefulInv,
						      usefulInv] THEN
Q.ABBREV_TAC `bs = DROP (LENGTH (ntms ug)) bs0` THEN

`gaw g1 nt (LAST (ntms g1))`

`∃ts. rule (LAST (ntms g1)) [TS ts] ∈ rules g1`

`∃ts. rule (LAST (ntms g1)) [TS ts] ∈ rules g2`

`∃g2. (fstNtm2Tm)^* (ntms ug, g1) ([],g2) ∧ eqLang g1 g2 ∧
			   inGnf (rules g3)-b rules`


`bInv (rules g1) (ntms g1) bs`

`bInv (rules g2) (ntms g2) bs`

`usefulInv g2`


`∃g3. (fstNtm2Tm)^* (TAKE (LENGTH ntms g1) bs0, g2) ([],g3) ∧ eqLang g2 g3 ∧
			   inGnf (rules g3)`



MAGIC);



 



val _ = export_theory ();



