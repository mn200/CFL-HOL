
\section{Introduction}

A context-free grammar (CFG) provides a simple and precise mechanism for describing the methods by which phrases in languages are built from smaller blocks, capturing the ``block structure'' of sentences.
The simplicity of the formalism makes it amenable to rigorous mathematical study.
Context-free grammars are also simple enough to allow the construction of efficient parsing algorithms using pushdown automata~(PDAs).
These ``predicting machines'' use knowledge about their stack contents to determine whether and how a given string can be generated by the grammar.
For example, PDAs underlie the construction of efficient parsers for LR grammars.

The theory of context-free languages is well understood and elegant.
It is also of clear practical importance, being the basis for the description and implementation of computer programming language syntax.
For these reasons, we feel it is a natural object for mechanised study.
Our contribution in this paper is to describe the mechanisation of a number of basic results in this area.
The most significant of these is the equivalence of the CFG and PDA models for context-free languages.
Needless to say, there is no doubt that this theory is in any doubt!
Nonetheless, there \emph{are} a number of other reasons for performing these mechanisations:
\begin{itemize}
\item We investigate the degree to which the mechanical system (HOL4~\cite{gordon93,SlindNorrish2008} in our case) is capable of dealing with such important mathematics.
\item We also provide an important basis for future, more complicated mechanised developments.  Without basic results such as those proved here, mechanised developments such as our verification of generation of SLR automata~\citep{Barthwal:ESOP2009:Verified-Parsing} would not be possible.
%
The library of proofs, techniques and notations developed here provides the basis from which further work on verified language theory can proceed at a quickened pace.
\item The mechanisation work is an engaging intellectual exercise in itself; performing proofs of this sort are a very good way to
\end{itemize}

The rest of the paper is structured as follows.
We introduce the basic details of our types (languages, grammars and automata) in Sections~\ref{sec:cfg} and~\ref{sec:pdaDef}.
In Section~\ref{sec:laeslafs} we describe the two ways in which a PDA can
accept an input (``acceptance by empty stack'' and ``acceptance by final state''), and show that they are equivalent in power.
In Sections~\ref{sec:cfg2pda} and \ref{sec:pda2cfg} we describe the mechanisation of the result that the CFGs and PDAs formalisms are equivalent in power.
Finally, we present some closure properties for context-free languages in Section~\ref{sec:closureProps}.

It turns out that closure under union, concatenation and Kleene closure~(Sections~\ref{sec:union} to~\ref{sec:kleene}) are easy to formalise.
These results depend on the fact that given any two grammars, $G_1$ and $G_2$, one can rename the variables such that variables of $G_1$ and $G_2$ are disjoint.
The main effort goes into establishing this `disjoint' property.
%
The two remaining closure properties illustrate how equivalence results for different models can be a great help: closure under substitution~(Section~\ref{sec:substitution}) uses a `parse tree' representation~(Section~\ref{sec:trees}) for derivations (rather than derivation lists), and closure under inverse homomorphism~(Section~\ref{sec:invhomomorphism}) relies on having an equivalent PDA for the given context-free grammar.

\paragraph{HOL4 Notation and Theorems}
All statements appearing with a turnstile ($\vdash$) are HOL4 theorems, automatically pretty-printed to \LaTeX{} from the relevant theory in the HOL4 development.
Notation specific to this paper is explained as it is introduced.
Otherwise, HOL4 supports a notation that is a generally pleasant combination of quantifiers ($\forall$, $\exists$) and functional programming ($\lambda$ for function abstraction, juxtaposition for function application).

Lists are written between square brackets, \emph{e.g.,} \HOLtm{[1;2]}.
The length of a list \HOLtm{l} is written~\HOLtm{LENGTH l}.
The concatenation of \HOLtm{l1} and \HOLtm{l2} is written \HOLtm{APPEND l1 l2}.
Overloading notation, we use $\in$ (and $\notin$) to refer to membership (non-membership) of both lists and sets.

If \HOLtm{R} is a (curried) binary relation (such that we write \HOLtm{R x y} when $x$ and $y$ are linked in the relation), then \HOLtm{RTC R} is the reflexive and transitive closure of $R$.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "pda"
%%% End:

% LocalWords:  PDAs CFGs CFG
